% 機率法則
% 陳鍾誠
% 2013 年 9 月 25 日

# 機率法則

# 機率統計架構圖
<center><img src="../img/ProbAndStatistics.png" width="600"/></center>

# 什麼是機率

# 機率的概念
- 樣本空間
- 樣本
- 某樣本發生的機率
- 事件
- 某事件發生的機率

# 樣本空間

- 機率論中，樣本空間是一個實驗或隨機試驗所有可能結果的集合
- 而隨機試驗中的每個可能結果稱為樣本點。通常用 S、&Omega; 或 U 表示。
- 例如，如果拋擲一枚硬幣，那麼樣本空間就是集合{正面，反面}。
- 如果投擲一個骰子，那麼樣本空間就是 {1,2,3,4,5,6} 。

# 事件

一個事件是由樣本空間中的一個子集合，例如令 A 為骰子的點數為 {1, 3, 5} 的事件，其機率可以寫為 P(A) = P({1,3,5})。

# 機率：事件的發生率

- 某個事件的發生率，機率很低代表該事件不太可能出現 (很罕見，但是並非不會出現)，機率很高代表該事件非常可能發生。

# 機率的詮釋方式
- 詮釋 1. 個人方式：(Personal Approach)
- 詮釋 2. 相對頻率方式 (Relative Frequency Approach) ： 
	- $P[A] = \frac{f}{n}$
- 詮釋 3. 古典方式 (Classical Approach) ： 
	- $P[A] = \frac{n(A)}{n(S)}$

# 詮釋 1. 個人方式
- Personal Approach
	- 完全按照個人直覺的解釋方式
- 說明：
	- 此方法不客觀

# 詮釋 2. 相對頻率方式
- Relative Frequency Approach
	- $P[A] = \frac{f}{n}$
- 說明：
	- f 為實驗中事件 A 出現的次數，n 為實驗進行的次數。 
	- 此方法乃是基於實驗觀察的結果的方式。

# 詮釋 3. 古典方式
- Classical Approach
	- $P[A] = \frac{n(A)}{n(S)}$
- 說明： 
	- n(A) 為事件 A 可能出現的次數 N(S) 為實驗可能進行的次數。
	- 此方法乃是將將實驗的可能出像 (outcome) 假設為等可能發生 (equaly likely)。

# 一般人對數學的想法
- 一般人學習數學的時候都是從直覺概念開始的
- 例如我們小學的時候透過算幾個蘋果學到加法
- 然後用好幾排的蘋果學到乘法
- 接著就會背誦九九乘法表
- 然後在中學的時候導入變數的觀念，於是學會了聯立方程式的解法。

# 公理系統

- 但是數學家們看數學往往是從公理系統開始的
- 透過公理系統進行推論以建立定理、然後推論出整個數學體系。
- 讓我們學習一下數學家的想法，先來看看機率的公理系統有何特色。

# 機率公理

以下三條法則是機率的基本公理：

- 公理 (1). $P(S) = 1$
 
- 公理 (2). $P(A) \ge 0$

- 公理 (3). $P(A1 \cup A2) = P(A1) + P(A2) \; ; \; if \; A1 \cap A2 = \emptyset$

# 公理(1)

- $P(S) = 1$
	- S 代表機率的樣本空間，也就是所有可能發生的事件所形成的集合，這個集合的發生機率為 1，意義是沒有任何事件落在樣本空間之外。

# 公理 (2) 
- $P(A) \ge 0$
	- A 代表任一事件，而 $P(A) \ge 0$  則代表任何事件的發生機率必須是正的，沒有負的機率值。

# 公理 (3) 
- $P(A1 \cup A2) = P(A1) + P(A2) \; ; \; if \; A1 \cap A2 = \emptyset$
	- A1, A2 代表任兩個事件，如果 A1 與 A2 沒有交集，那麼其聯集發生的機率將會是其機率的總和，也就是 $P(A1 \cup A2) = P(A1) + P(A2)$ 。

# 機率定理

當這個公理系統確定下來之後，我們就可以透過這些法則進行一些基本的推論，舉例而言，我們應該可以很容易的證明以下這些定理。

- 定理 1. $P(\emptyset) = 0$
- 定理 2. $P(A') = 1-P(A)$
- 定理 3. $P(A1 \cup A2) = P(A1) + P(A2) - P(A1 \cap A2)$

# 習題
- 請證明以上定理

# 機率定理的意義

- 但是，這些定理又代表甚麼意義呢？
- 其實從凡氏圖上可以很清楚的看得出來這些定理的直覺意義。

# 兩個集合的凡氏圖

![圖、兩個集合 A, B 的凡氏圖](../img/VennsDiagramAB.jpg)

# 三個個集合的凡氏圖

![圖、三個集合 A, B, C 的凡氏圖](../img/VennsDiagram.png)

# 習題 1：機率定理的證明

> 定理：證明 $P(\emptyset) = 0$ 
> 
> 證明：
> 
> $P(S\cup\emptyset) = P(S)+P(\emptyset)$ ; 根據公理 (3)
> 
> $S = S\cup\emptyset$ ; 根據集合論
> 
> $P(S) = 1$ ; 根據公理 1
> 
> $1 = P(S) = P(S\cup\emptyset) = P(S)+P(\emptyset)$ ; 根據集合論與公理 (3)
> 
> 所以 $P(\emptyset) = 1-P(S) = 1-1 = 0$

# 習題 2：機率定理的證明

> 定理：證明 P(A') = 1-P(A) ; 其中的 A' 代表 A 的補集，也就是 $A\cup A' = S ; A\cap A' = \emptyset$
> 
> 證明：
> 
> 因為 $A\cup A' = S ; A\cap A' = \emptyset$ ; 根據 A' 的定義
> 
> $P(A' \cup A) = P(A') + P(A)$ ; 根據公理 3
> 
> $P(A') + P(A) = P(A' \cup A) = P(S) = 1$ ; 根據公理 3 與公理1
> 
> 所以 $P(A') = 1-P(A)$
 
# 習題 3：機率定理的證明

> 定理：證明 $P(A1 \cup A2) = P(A1) + P(A2) - P(A1 \cap A2)$ 
> 
> 證明：
> 
> 因為 $A1 \cup A2 = (A1-(A1 \cap A2)) \cup A2$ ; 根據集合論 (用文氏圖可以理解其直覺意義)
> 
> $(A1-(A1 \cap A2)) \cap A2 =  \emptyset$  ; 根據集合論 (用文氏圖理解，只是為了方便)
> 
> $P(A1) = P((A1-(A1 \cap A2))\cup (A1 \cap A2) ) = P(A1-(A1 \cap  A2)) + P (A1\cap A2)$ ; 根據公理 3
> 
> 所以 $P(A1-(A1 \cap  A2)) = P(A1) -  P (A1\cap A2)$
> 
> 推論 $P(A1 \cup A2) = P((A1-(A1 \cap  A2)) \cup A2) = P(A1-(A1 \cap  A2)) + P(A2)$ 
> 
> $=  P(A1) -  P (A1\cap A2) + P(A2) = P(A1) + P(A2) -  P (A1\cap A2)$  ;
> 
> 所以 $P(A1 \cup A2)= P(A1) + P(A2) -  P (A1\cap A2)$

# 機率模型

- 因此、只要指定了所有可能事件的發生率，我們就可以完整的描述一個機率模型。
- 舉例而言，日常生活中最常見的機率模型，大概就是丟銅板和擲骰子了
- 以下是我們對這兩個機率系統的描述。

# 範例 1：丟銅板

> 在投擲銅板的機率過程中，其樣本空間 S={正, 反} ，
> 
> 而其中一個常見的隨機變數 X ，是用來計算銅板的正面數量，
> 	
> 此時，P(正) = 0.5，而 P(反) = 0.5

# 範例 2：擲骰子
 
> 在投擲骰子的機率過程中，其樣本空間 S={1點,2點,3點,4點,5點,6點}，
> 
> 此時，P(1點) = P(2點) = ... = P(6點) = 1/6。

所以，在一次擲骰子中，得到 5 點或者 6 點的機率，可以圖示如下。

![圖、擲一次骰子 5 點或 6 點的機率](../img/dice56prob.jpg)

# 練習：R 軟體與機率密度函數

- 我們可以透過 R 軟體進一步瞭解機率密度函數的意義
- 舉例而言， R 當中有個 sample() 函數，
- 我們只要使用該函數就可以模擬擲骰子或銅板的過程。

# R 軟體的 ?Help 功能
- 您可以用 「?函數」 的方式查詢某函數的功能
- 因此當我們在 R 軟體中鍵入 ?sample 時
- R 軟體會輸出下列訊息：

```
> ?sample
starting httpd help server ... done
```

# R 軟體 ?Sample 的結果

然後就開啟下列的網頁畫面

![圖、sample 函數的 Help 畫面](../img/sampleHelp.jpg)

您可以看到 sample 函數的原型為 `sample(x, size, replace = FALSE, prob = NULL)`，於是可以用下列指令模擬投擲骰子十次的行為。

# R: Sample 函數的用法

```
> sample(1:6, 10)
錯誤在sample(1:6, 10) : 
  cannot take a sample larger than the population when 'replace = FALSE'
> sample(1:6, 10, replace=TRUE)
 [1] 3 2 4 4 4 2 6 3 3 3
> 
```

- 說明
	- 您可以看到當我們用 `sample(1:6, 10, replace=TRUE)` 的指令時
	- 可以正確的模擬出投擲骰子十次的隨機過程，得到 3 2 4 4 4 2 6 3 3 3 這個序列，
	- 但是若我們沒有指定 replace=T (TRUE)，的時候，代表要採用取樣後不放回的方式，
	- 但是這種方式最多只能做六次，所以就得到失敗的結果。

# R: 取後不放回的 Sample()

- 不過如果我們指定的樣本數 k 在六個以下
- 那麼 sample(1:6, k) 是會成功的，以下是一個範例：

```
> sample(1:6, 6)
[1] 2 6 4 1 5 3
```

# R: 模擬投擲銅板的過程

- 同樣的，我們也可以用 sample 函數模擬投擲銅板的過程
- 只是由於同板只有兩個面 (正面與反面)
- 因此我們可以用以下的方式模擬：

```R
> face = c("正", "反")
> sample(face, 10, replace=TRUE)
 [1] "正" "反" "正" "反" "反" "正" "反" "正" "正" "反"
```

- 上述模擬中的第一個指令 `face = c("正", "反")`
- 代表我們要建立一個有兩個字串元素 [ 正, 反] 的陣列。
- 然後第二個指令 `sample(face, 10, replace=TRUE)` 就用這樣的陣列去產生 10 個樣本 (取後放回的方式)。

# 機率不平均的取樣

- 有時候，我們希望模擬的事物，其機率並非平均的
- 舉例而言，像是灌過鉛的骰子，或者是像台灣的廟裏面常見的「擲茭」
- 其機率可能是不平均的
- 對這種情況我們就可以指定 
	- `sample(x, size, replace = FALSE, prob = NULL)` 
	- 這個函數的第四個參數，也就是 prob 來模擬。

# R: 模擬擲茭的過程

舉例而言，假如「擲茭」的正面機率是 0.6，而反面機率是 0.4，那麼我們就可以用下列方式模擬「擲茭」十次的過程。

```R
> sample(face, 10, replace=TRUE, c(0.6, 0.4))
 [1] "反" "正" "反" "反" "反" "正" "正" "正" "正" "正"
```

# 條件機率 

> *條件機率的定義*：
> 
> 在 A 事件出現的情況下，B 事件出現的機率，稱為 P(B|A)。
> 
> $P(B|A) = \frac{P(A \cap B)}{P(A)}$

範例 1：

> 舉例而言，假如我們已知某投擲骰子的結果為偶數 (事件 A=偶數)，那麼結果為 3 點 (事件 B=3點) 的機率為多少？
> 
> 這個條件機率可以用下列算式表示。
> 
> P(B|A) = P(3點|偶數)

範例 2：

> 當然、B 不一定要是 A 的子集合，舉例而言，假如 B 為「不大於 3 點」的事件，那麼我們就可以將條件機率表示如下：
> 
> P(B|A) = P(不大於3點|偶數)

# 獨立事件

> *獨立事件的定義* : 
> 
> 事件 A 與 B 彼此獨立，則 A, B 兩事件同時出現的機率為
> 
> $P(A \cap B) = P(A) P(B)$

請注意數學中定義的意義，定義代表某種規定，是不需要證明的，只要不符合這種規定的，就不能用此一名詞描述，也就是不符合此定義。

因此、並非所有的事件 A, B 都會是獨立的，但若事件 A, B 符合上述規定的話，我們就稱這兩個事件彼此獨立。

舉例而言，假如對於一個公平的骰子而言，請問下列的 A,B 事件之間是否彼此獨立。

範例 1. 兩事件不獨立的情況

> 問題：請問 「A=偶數, B=3點」這兩個事件是否獨立
> 
> 解答：
> 
> P(A) = 3/6 = 1/2
> 
> P(B) = 1/6
> 
> P(A &cap; B) = 0
> 
> P(A) P(B) = 1/2 * 1/6 =1/12
>
> 由於 P(A \cap B) \ne P(A) P(B) ，所以這兩個事件彼此不獨立。

範例 2. 兩事件獨立的情況

> 問題：請問 「A=偶數, B=不大於 4 點」這兩個事件是否獨立
> 
> 解答：
> 
> P(A) = 3/6 = 1/2 
> 
> P(B) = 4/6 = 2/3
> 
> P(A &cap; B) = P({2點, 4點}) = 2/6 = 1/3
> 
> P(A) P(B) = 1/2 * 2/3 = 1/3
>
> 由於 P(A &cap; B) = P(A) P(B) ，所以這兩個事件彼此獨立。


習題：請證明以下定理：

> 定理 1. 若 A , B 彼此獨立，則 $P(A|B) = P(B|A) * \frac{P(A)}{P(B)}$
> 
> 定理 2. $A_1, A_2, ... , A_k$  彼此獨立 <=> $P(A_1 \cap A_2 ... \cap A_k) = P(A_1) P(A_2) ... P(A_k)$
> 
> 定理 3. 乘法規則：$P(A \cap B) = P(B|A) P(A)$

# 貝氏定理

> *貝氏定理*：$P(A | B) = P(B | A)  \frac{P(A)}{P(B)}$
> 
> 證明：
> 
> 由條件機率的定義可得 $P(B | A) = \frac{P(A \cap B)}{P(A)}$，也可以得到 $P(A | B) = \frac{P(A \cap B)}{P(B)}$
> 
> 所以  $P(A \cap B) = P(B|A) P(A) = P(A|B) P(B)$
> 
> 於是得到 $P(A | B) = P(B | A)  \frac{P(A)}{P(B)}$

習題：

> 習題 1. 請驗證 「A=偶數, B=3點」這兩個事件是否符合貝氏定理
> 
> 習題 2. 請驗證 「A=偶數, B=不大於 4 點」這兩個事件是否符合貝氏定理


# 條件獨立

> *條件獨立的定義*：
> 
> 假如 A 與 B 在給定 C 的情況下條件獨立，那麼以下算式成立：
> 
> $P(A,B|C) = P(A|C) * P(B|C)$ ;

習題：請證明以下定理：

> 定理： $P(A,B|C) = P(C|A)* P(C|B)*\frac{P(A) P(B)}{P(C)^2}$


# 習題：牙疼的診斷問題

本問題來自人工智慧的經典教科書 「Artificial Intelligence: A Modern Approach」第三版，475 頁。

問題描述：當病人來看牙醫時，該病人可能有蛀牙或沒蛀牙，也可能有牙痛或沒有牙痛，而牙醫可能會找到牙痛的原因或找不到。

因此有下列三個隨機變數

X:(蛀) 蛀牙與否 (Cavity)
Y:(痛) 牙痛與否 (Toothache)
Z:(找) 是否找到痛的牙 (Catch)

假如這個問題個統計機率都已經知道了，如下表所示。

|               | 牙痛 (Y=1)  |              | 不牙痛 (Y=0)    |                  |
|---------------|-------------|--------------|-----------------|------------------|
|               | 找到 (Z=1)  | 找不到 (Z=0) | 找到 (Z=1)      | 找不到 (Z=0)     |
| 蛀牙(X=1)     | 0.108       | 0.012        | 0.072           | 0.008            |
| 沒蛀牙 (X=0)  | 0.016       | 0.064        | 0.144           | 0.576            |

請回答下列問題

* 問題 1：請計算 P(沒痛) = ? 
* 問題 2：請計算 P(找到 | 牙痛) = ? 
* 問題 3：請問這是一個合理的機率分布嗎？
* 問題 4：請計算 P(找到 | 蛀牙) = ? 
* 問題 5：請計算 P(找到, 牙痛) = ? 
* 問題 6：請計算 P(蛀 | 找到),  P(蛀), P(找到),  P(找到 | 蛀) ，然後驗證下列貝氏定理是否成立。
    * P(找到|蛀) = P(蛀|找到) P(找到)/P(蛀)

解答

R 的 陣列是用以行為主的順序 (Column Major Order)，請看下列檔案中的說明：

* <http://cran.r-project.org/doc/manuals/R-lang.pdf>

> 2.2.2 The dim attribute is used to implement arrays. The content of the array is stored in a
vector in column-major order and the dim attribute is a vector of integers specifying the
respective extents of the array. R ensures that the length of the vector is the product of
the lengths of the dimensions. The length of one or more dimensions may be zero.

所以我們必須用以行為主的順序 (Column Major Order) 將機率列舉出來，如下表所示：

| 蛀 X | 痛 Y | 找 Z | P(X,Y,Z) | 
|------|------|------|----------| 
| 0    | 0    | 0    |  0.576   | 
| 1    | 0    | 0    |  0.008   | 
| 0    | 1    | 0    |  0.064   | 
| 1    | 1    | 0    |  0.012   | 
| 0    | 0    | 1    |  0.144   | 
| 1    | 0    | 1    |  0.072   | 
| 0    | 1    | 1    |  0.016   | 
| 1    | 1    | 1    |  0.108   |

而且 R 的陣列是從 1 開始算的，不像 C 語言是從 0 開始算的，因此還必須將上表修改如下：

| 蛀 X | 痛 Y | 找 Z | P(X,Y,Z) | 
|------|------|------|----------| 
| 1    | 1    | 1    |  0.576   | 
| 2    | 1    | 1    |  0.008   | 
| 1    | 2    | 1    |  0.064   | 
| 2    | 2    | 1    |  0.012   | 
| 1    | 1    | 2    |  0.144   | 
| 2    | 1    | 2    |  0.072   | 
| 1    | 2    | 2    |  0.016   | 
| 2    | 2    | 2    |  0.108   |


```R
> p <- array(c(0.576, 0.008, 0.064, 0.012, 0.144, 0.072, 0.016, 0.108),c(2,2,2))
> p
, , 1

      [,1]  [,2]
[1,] 0.576 0.064
[2,] 0.008 0.012

, , 2

      [,1]  [,2]
[1,] 0.144 0.016
[2,] 0.072 0.108

> p[1,1,1]
[1] 0.576
> p[2,1,1]
[1] 0.008
> p[1,2,1]
[1] 0.064
> p[2,2,1]
[1] 0.012
> p[1,1,2]
[1] 0.144
> p[2,1,2]
[1] 0.072
> p[1,2,2]
[1] 0.016
> p[2,2,2]
[1] 0.108
> dimnames(p)[[1]] = c("沒蛀", "蛀")
> dimnames(p)[[2]] = c("沒痛", "痛")
> dimnames(p)[[3]] = c("沒找", "找")
> p
, , 沒找

      沒痛    痛
沒蛀 0.576 0.064
蛀   0.008 0.012

, , 找

      沒痛    痛
沒蛀 0.144 0.016
蛀   0.072 0.108
```

解答1：P(沒痛) =  0.8
計算過程：

```R
> p[,"沒痛",]
      沒找    找
沒蛀 0.576 0.144
蛀   0.008 0.072
> sum(p[,"沒痛",])
[1] 0.8
```

解答2：P(找到 | 牙痛) = 0.62

```R
> p[,,"找"]
      沒痛    痛
沒蛀 0.144 0.016
蛀   0.072 0.108
> sum(p[,,"找"])
[1] 0.34
> sum(p[,"痛","找"])
[1] 0.124
> sum(p[,"痛","找"])/sum(sum(p[,"痛",]))
[1] 0.62
```

解答3：請問這是一個合理的機率分布嗎？ (是的，因為總和為 1，而且每個機率直都介於 0 到1之間)

```R
> sum(p)
[1] 1
> 0<=p & p <=1
, , 沒找

     沒痛   痛
沒蛀 TRUE TRUE
蛀   TRUE TRUE

, , 找

     沒痛   痛
沒蛀 TRUE TRUE
蛀   TRUE TRUE

```

問題 4：請計算 P(找到 | 蛀牙) = ? 

```R
>  sum(p["蛀",,"找"])/sum(p["蛀",,])
[1] 0.9
```

問題 5：請計算 P(找到, 牙痛) = ? 

```R
> sum(p[,"痛","找"])
[1] 0.124
```

解答6：請計算 P(蛀 | 找到), P(蛀), P(找到), P(找到 | 蛀) ，然後驗證下列貝氏定理是否成立。

> P(蛀 | 找到) = p(找到|蛀) * p(蛀)/p(找到)

說明：

P(蛀 | 找到) = 0.5294118, P(蛀)=0.2, P(找到)=0.34, P(找到 | 蛀)=0.9

P(蛀 | 找到) = 0.5294118 = 0.9 * 0.2/0.34 =  = p(找到|蛀) * p(蛀)/p(找到)

```R
> pab = sum(p["蛀",,"找"])/sum(p[,,"找"]) # pab = P(蛀 | 找到)
> pba = sum(p["蛀",,"找"])/sum(p["蛀",,]) # pba = P(找到 | 蛀)
> pa = sum(p["蛀",,]) # pa = P(蛀)
> pb = sum(p[,,"找"]) # pb = P(找到)
> pab
[1] 0.5294118
> pba
[1] 0.9
> pa
[1] 0.2
> pb
[1] 0.34
> pba*pa/pb
[1] 0.5294118
> pab-pba*pa/pb
[1] 0

```

所以 

```R
p(蛀|找) 
= sum(p["蛀",,"找"])/sum(p[,,"找"]) 
= pab 
= pba * pa / pb 
= p(找|蛀) * p(蛀)/p(找) 
= sum(p["蛀",,"找"])/sum(p[,,"蛀"])* sum(p[,,"蛀"])/ sum(p["找",,])
```

完整的操作過程

```R
> p <- array(c(0.576, 0.008, 0.064, 0.012, 0.144, 0.072, 0.016, 0.108),c(2,2,2))
> p
, , 1

      [,1]  [,2]
[1,] 0.576 0.064
[2,] 0.008 0.012

, , 2

      [,1]  [,2]
[1,] 0.144 0.016
[2,] 0.072 0.108

> p[1,1,1]
[1] 0.576
> p[2,1,1]
[1] 0.008
> p[1,2,1]
[1] 0.064
> p[2,2,1]
[1] 0.012
> p[1,1,2]
[1] 0.144
> p[2,1,2]
[1] 0.072
> p[1,2,2]
[1] 0.016
> p[2,2,2]
[1] 0.108
> dimnames(p)[[1]] = c("沒蛀", "蛀")
> dimnames(p)[[2]] = c("沒痛", "痛")
> dimnames(p)[[3]] = c("沒找", "找")
> p
, , 沒找

      沒痛    痛
沒蛀 0.576 0.064
蛀   0.008 0.012

, , 找

      沒痛    痛
沒蛀 0.144 0.016
蛀   0.072 0.108

> p[,"沒痛",]
      沒找    找
沒蛀 0.576 0.144
蛀   0.008 0.072
> p[,,"找"]
      沒痛    痛
沒蛀 0.144 0.016
蛀   0.072 0.108
> sum(p[,,"找"])
[1] 0.34
> sum(p[,"痛","找"])
[1] 0.124
> sum(p[,"痛","找"])/sum(sum(p[,"痛",]))
[1] 0.62
> sum(p)
[1] 1
> 0<=p & p <=1
, , 沒找

     沒痛   痛
沒蛀 TRUE TRUE
蛀   TRUE TRUE

, , 找

     沒痛   痛
沒蛀 TRUE TRUE
蛀   TRUE TRUE

> sum(p["蛀",,"找"])/sum(p["蛀",,])
[1] 0.9
> sum(p["蛀",,"找"])/sum(p["蛀",,])
[1] 0.9
> sum(p[,"痛","找"])/sum(p[,"痛",])
[1] 0.62
> sum(p[,"痛","找"])
[1] 0.124
> pab = sum(p["蛀",,"找"])/sum(p[,,"找"]) # pab = P(蛀 | 找到)
> pba = sum(p["蛀",,"找"])/sum(p["蛀",,]) # pba = P(找到 | 蛀)
> pa = sum(p["蛀",,]) # pa = P(蛀)
> pb = sum(p[,,"找"]) # pb = P(找到)
> pab
[1] 0.5294118
> pba
[1] 0.9
> pa
[1] 0.2
> pb
[1] 0.34
> pba*pa/pb
[1] 0.5294118
> pab-pba*pa/pb
[1] 0
> 
```

