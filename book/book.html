<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="陳鍾誠" />
  <title>人工智慧 - 採用 JavaScript 實作</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/book.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
  <h1><a href="book.html">人工智慧 - 採用 JavaScript 實作</a></h1>
  <table id="bar" border="0" style="border:0;"><tr style="border:0;">
    <td style="text-align:left;border:0;"> <a href="book.html">目錄</a> | <a href="download.html">下載</a></td>
    <td style="text-align:right;border:0;"><a href="http://ccckmit.wikidot.com/">陳鍾誠</a> 於 <a href="http://www.nqu.edu.tw/">金門大學</a></td>
  </tr></table>
</div>
<div id="content">
<div id="header">
<h1 class="title">人工智慧 - 採用 JavaScript 實作</h1>
<h2 class="author">陳鍾誠</h2>
<h3 class="date">2014 年 8 月</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#授權聲明">授權聲明</a></li>
<li><a href="#人工智慧簡介">人工智慧簡介</a><ul>
<li><a href="#何謂人工智慧-ai">何謂人工智慧 (AI) ?</a></li>
<li><a href="#ai-的方法">AI 的方法</a></li>
<li><a href="#ai-的夢想">AI 的夢想</a></li>
</ul></li>
<li><a href="#爬山演算法">爬山演算法</a><ul>
<li><a href="#實作以爬山演算法尋找函數最高點">實作：以爬山演算法尋找函數最高點</a></li>
<li><a href="#實作通用的爬山演算法架構">實作：通用的爬山演算法架構</a></li>
<li><a href="#實作通用的模擬退火法架構">實作：通用的「模擬退火法」架構</a></li>
</ul></li>
<li><a href="#神經網路簡介">神經網路簡介</a><ul>
<li><a href="#實作單層感知器-perceptron">實作：單層感知器 (Perceptron)</a></li>
<li><a href="#實作多層感知器與反傳遞演算法">實作：多層感知器與反傳遞演算法</a></li>
<li><a href="#圖形搜尋簡介">圖形搜尋簡介</a></li>
<li><a href="#實作深度與廣度搜尋法">實作：深度與廣度搜尋法</a></li>
<li><a href="#實作以深度優先搜尋解決老鼠走迷宮問題">實作：以深度優先搜尋解決老鼠走迷宮問題</a></li>
<li><a href="#實作以廣度優先搜尋解決拼圖問題">實作：以廣度優先搜尋解決拼圖問題</a></li>
</ul></li>
<li><a href="#電腦下棋">電腦下棋</a><ul>
<li><a href="#實作五子棋程式">實作：五子棋程式</a></li>
<li><a href="#電腦下棋的關鍵-min-max-對局搜尋與-alpha-beta-修剪算法">電腦下棋的關鍵： Min-Max 對局搜尋與 Alpha-Beta 修剪算法</a></li>
</ul></li>
<li><a href="#邏輯推論與專家系統">邏輯推論與專家系統</a><ul>
<li><a href="#布林邏輯">布林邏輯</a></li>
<li><a href="#謂詞邏輯">謂詞邏輯</a></li>
<li><a href="#一階邏輯">一階邏輯</a></li>
<li><a href="#二階邏輯">二階邏輯</a></li>
<li><a href="#專家系統">專家系統</a></li>
<li><a href="#實作布林邏輯的推論引擎">實作：布林邏輯的推論引擎</a></li>
<li><a href="#實作專家系統---前向推論程式">實作：專家系統 - 前向推論程式</a></li>
<li><a href="#實作專家系統---互動推論程式">實作：專家系統 - 互動推論程式</a></li>
<li><a href="#實作謂詞邏輯的推論引擎">實作：謂詞邏輯的推論引擎</a></li>
</ul></li>
<li><a href="#結語-11">結語</a><ul>
<li><a href="#ai-的夢想-1">AI 的夢想</a></li>
<li><a href="#ai-的困境">AI 的困境</a></li>
<li><a href="#未來展望">未來展望</a></li>
</ul></li>
</ul>
</div>
<h2 id="序"><a href="#序">序</a></h2>
<p>人工智慧的書籍，往往理論眾多，看完之後卻完全不知道怎麼實作。為了彌補這個缺陷，我們採用實作導向的方式，來說明人工智慧的各種理論，希望透過這些程式，讓讀者對抽象的理論能夠有實際的感受。</p>
<p>陳鍾誠 2014/6/16 於 金門大學 資訊工程系</p>
<h2 id="授權聲明"><a href="#授權聲明">授權聲明</a></h2>
<p>本課程內容由 <a href="http://ccckmit.wikidot.com/">金門大學</a> 創建，期中部分內容與圖片來自 <a href="http://zh.wikipedia.org">維基百科</a>，因此採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">創作共用：姓名標示、相同方式分享</a> 之授權。</p>
<p>若您想要修改本書產生衍生著作時，至少應該遵守下列授權條件：</p>
<ol style="list-style-type: decimal">
<li>標示原作者姓名為 <a href="http://ccckmit.wikidot.com/">陳鍾誠</a> 衍生自 <a href="http://zh.wikipedia.org">維基百科</a> 的作品。</li>
<li>採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">創作共用：姓名標示、相同方式分享</a> 的方式公開衍生著作。</li>
</ol>
<h1 id="人工智慧簡介"><a href="#人工智慧簡介">人工智慧簡介</a></h1>
<blockquote>
<p>玄之又玄、眾妙之門 -- 老子 道德經</p>
</blockquote>
<p>人工智慧 AI (Artificial Intelligence) 領域，可以說是資訊科學界的聖杯，或者說，更像是魔戒。這個令人想像就足以感到目眩神迷的領域，吸引了一代又一代的資訊科學研究者，不斷的投入這些令人望而生畏的問題當中。不知是因為勇氣還是利慾薰心，資訊科學研究者在此領域當中勇往直前，不斷失敗卻前仆後繼。許多人投入了一輩子，卻沒有得到想像中的成果，甚至連門口都沒進去，就已經陣亡了。人工智慧領域的理論已經成為一個龐然大物，想入門的人在看到這樣一個盤根錯節的碩大的身軀時，往往還沒到門口，就已經迷路了。而其他的人呢？則是在進了門之後，找不到出去的路。</p>
<p>「仰之彌高，鑽之彌堅，瞻之在前，忽焉在後」，這句被用來形容孔子的話，我覺得用來形容「人工智慧」會更為貼切一些。往往當研究者認為自己已經看到某些解答時，最後只發現了原來是一場夢。當問題看來如此的簡單之時，其實門內躲了一個妖精或怪獸，正虎視眈眈的看著你，他們打算先引你進來再吃掉你。在人工智慧領域迷路的人，通常不是被怪獸吃掉，而是被妖精用美色迷惑。最後，以為自己到了天堂，其實是精盡人亡後，下了地獄而不自知。如果你想看看這個妖精所在的世界，就請隨我而來吧。</p>
<p>研究 AI 的學者，或許更像金庸小說中俠客島上的江湖人物一樣，到了俠客島之後就被那些精妙的武功祕及所迷住了，再也不願意返回到原本的江湖中，畢生研究的武學也就毫無用處了。</p>
<p>俠客島上的人物，只看到秘笈中的文字，卻看不見文字筆勢上所蘊含的圖像式武學，因而錯失了真正精妙的武功之所在。或許，研究 AI 的學者也有同樣的問題，總是沉迷在各種看似高深的算法當中，卻又見樹不見林，以致於無法看見整體的智慧是如何形成的，這恐怕是 AI 領域的研究者未來所必須面對的挑戰。</p>
<p>在本書中，我們雖然會介紹 AI 的主要理論，但是卻希望讀者能回到現實上，以實作感受 AI 這些方法的意義，而不是只有理論闡述。即使如此，筆者目前仍然沒有任何能力，能告訴讀者如何才能拿到那個聖杯，或許這個聖杯根本就不存在也說不定。</p>
<h2 id="何謂人工智慧-ai"><a href="#何謂人工智慧-ai">何謂人工智慧 (AI) ?</a></h2>
<p>終於到了我們為人工智慧下定義的時候了，我們認為，AI 的定義，與其用技術方式，不如用目標的方式定義更恰當。AI 的目標是企圖模擬人類，建構出具有類似人類大腦的程式。這包含使用眼睛、耳朵、嘴巴、手腳、身體等器官的能力。</p>
<p>因此，AI 的目標乃是模擬人類大腦，並利用電腦的眼睛 (攝影機)、耳朵 (麥克風)、嘴巴 (喇叭)、手腳與身體 (機器人)，取得外在世界的資訊，根據這些資訊進行類似人類的智慧型行為，像是影像辨識 (眼睛)、手寫辨識 (眼睛)、語音辨識 (耳朵)、機器人控制 (手腳與身體) 等，都是典型的 AI 領域。當然，還有許多與感官無關的領域，像是電腦下棋、自然語言理解、機器翻譯、知識工程等，這些都是與大腦的功能直接相關的領域，也是AI 領域當中的經典問題。</p>
<p>AI 是以電腦程式模擬人類的智慧行為，包含眼睛、耳朵等感官的「聽、說、讀、寫」，與大腦的「推理、理解、學習」，還有動作類的「手、腳、身體、控制」等行為。</p>
<table>
<thead>
<tr class="header">
<th align="left">模擬行為</th>
<th align="left">相關應用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">感知</td>
<td align="left">語音辨識 (耳朵)、影像辨識 (眼睛)、手寫辯識(眼睛)、指紋辯識(眼睛)</td>
</tr>
<tr class="even">
<td align="left">推理</td>
<td align="left">專家系統、電腦遊戲、電腦下棋、醫療診斷 (大腦)</td>
</tr>
<tr class="odd">
<td align="left">理解</td>
<td align="left">機器翻譯、交談系統 (大腦)</td>
</tr>
<tr class="even">
<td align="left">學習</td>
<td align="left">電腦下棋、專家系統、醫療診斷、辯識 (大腦)</td>
</tr>
<tr class="odd">
<td align="left">動作</td>
<td align="left">機器人足球賽、自動駕駛、商用機器人、智慧型控制器 (手腳身體)</td>
</tr>
</tbody>
</table>
<h2 id="ai-的方法"><a href="#ai-的方法">AI 的方法</a></h2>
<p>人工智慧的方法非常多樣，早期的人工智慧研究聚焦在邏輯推論的方法，後來越來越多元化，像是類神經網路、模糊推論、遺傳演算法、機率模型等都被包含進來。</p>
<p>邏輯推論的方法，由於需要百分之百確定的事實配合，因此在實務上不容易使用，因此像模糊推論等方法，雖然在理論上較不優美，但是在實務上卻很有用。類神經網路則是在影像辨識、語音辨識等領域，表現得較為傑出。</p>
<p>近來，機率式的方法開始越來越受到重視，像是 Hidden Markov Model (HMM)、Bayes Network、Monte Carlo Marko Chain (MCMC)、Expectation-Maximization (EM) 等方法，都有越來越多的應用。舉例而言，HMM 在語音辨識上具有非常好的辨識率、而 EM 學習演算法則在機器翻譯上被大量的使用。</p>
<p>由於機率式的方法在數學理論上較為完備，因此有更多的數學工具可以使用，因此未來人工智慧與數學的關係應該會越來越密切，這個領域將有待數學背景強的新研究者加入與探索，以便創造出更好的數學模型，讓 AI 成為一門「真正的科學」。</p>
<p>為了讓電腦實現上述的智慧型功能，研究者這幾十年來發展出了以下的方法，這些方法有些只適用於少數應用，而有些則可以適用於很多類的應用。</p>
<table>
<thead>
<tr class="header">
<th align="left">分類</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">搜尋</td>
<td align="left">DFS, BFS, Best-FS, A*, Min-Max+α-β Cut, Dynamic Programming,</td>
</tr>
<tr class="even">
<td align="left">最佳化</td>
<td align="left">Greedy Algorithm, Simulate Annealing, Genetic Algorithm</td>
</tr>
<tr class="odd">
<td align="left">邏輯推論</td>
<td align="left">Boolean Logic, First-Order Logic, Probabilistic Logic, Fuzzy Logic</td>
</tr>
<tr class="even">
<td align="left">神經網路</td>
<td align="left">Back Propagation Network, Hopfield Network</td>
</tr>
<tr class="odd">
<td align="left">機率統計</td>
<td align="left">Bayesian Network, Hidden Markov Model, EM algorithm</td>
</tr>
<tr class="even">
<td align="left">比對</td>
<td align="left">Pattern Matching, Regular Expression, …</td>
</tr>
</tbody>
</table>
<p>盡管我們對 AI技術的期待越來越往後延，但是，這並不代表 AI 的方法越來越落後。相反的，理論不斷的創新，而且越來越具有實務性。AI 理論已經是資訊科學領域當中最為龐大的一個分支，任何的教科書想要全面介紹這些理論，都彷彿是在完成不可能的任務。</p>
<h3 id="搜尋法"><a href="#搜尋法">搜尋法</a></h3>
<p>搜尋法一直是 AI 研究的主要方法，但是很少人會將邏輯推論與類神經網路也視為一種搜尋法。然而，近來的發展顯示，用搜尋法的觀點，可以很清楚的看出每一個方法都優缺點，其他的各種方法也都可以用搜尋法的角度，進行理論上的分析。</p>
<p>許多無法歸類到邏輯推論與類神經網路的方法，像是 <em>「貪婪式演算法、模擬退火法、遺傳演算法、鳥群演算法、蟻群演算法」</em> 等等，都是在進行搜尋工作。</p>
<h3 id="邏輯推論"><a href="#邏輯推論">邏輯推論</a></h3>
<p>有些 AI 研究人員認為可以將全世界的知識，透過邏輯敘述的方式累積，然後利用這些知識進行推論，這便是知識工程或專家系統的任務。此種方式企圖直接解答智慧之謎，其研究方法上認為『知識 = 智慧』。</p>
<p>從早期的「布林邏輯、洪氏邏輯、一階邏輯」等確定性的邏輯系統開始，發展出了「計劃系統、專家系統」等模擬大腦推理行為的系統，這讓邏輯推論成為了人工智慧的核心方法，但由於這些推理方法需要建構在 100% 確定的事實，並依賴 100% 確定的推理法則才能進行，因此在複雜的現實事件通常很難使用。</p>
<p>後來的 AI 研究逐漸導向「非確定性」的推論方法上，像是「模糊推論、機率推論」等方法，這些推理方法比較能夠在「現實世界」中有效的運用，因此近來的人工智慧研究者大多採用這類的方法近型更深入的研究。</p>
<h3 id="類神經網路"><a href="#類神經網路">類神經網路</a></h3>
<p>類神經在 1986 年之後，開始吸引了許多研究者的目光，原因是此類方法在語音與影像識別上，具有優秀的表現，將手寫辨識與語音識別等問題的正確率拉到了 80 % 左右。這使得這個曾經被 Malvin Minsky 這位類神經先驅證明為不可行的方法 成為當紅炸子雞。</p>
<p>現在，我們知道，類神經網路在影像辨識、語音識別等領域上表現很好，但是，類神經網路在符號式的領域，像是自然語言與機器翻譯上，就顯得力有未逮，甚至是格格不入了。</p>
<p>其實，邏輯推論與類神經網路，都可以視為搜尋方法的一種特例。因為，這些方法都是在搜尋問題的答案，然而在問題的表達上，布林邏輯堆論採用了二分法，也就是只有 0 與 1 的世界。而類神經網路，則採用了實數的方式表達神經元之間的強度，於是造成了一個由實數所構成的世界。這兩者並非是互斥的，或許，在未來，我們會發現兩者攜手合作的研究陸續出現。</p>
<h3 id="機率統計"><a href="#機率統計">機率統計</a></h3>
<p>機率統計方法在其他領域通常很快就成為主流方法，但是在 AI 領域卻經過了很久都沒受到重視，直到最近由於隱馬可夫模型 (HMM) 逐漸在語音辨識領域嶄露頭角，才開始有越來越興盛的趨勢。最近，統計方法在機器翻譯上有越來越強的趨勢，像是貝氏網路 (Bayisian Network)、期望最佳化學習法 (Expectation-Maximization, EM)、蒙地卡羅馬可夫學習法 (Montecarlo Markov Chain, MCMC) 等，都開始展露其優勢，相信在未來的幾年，機率統計法將會在 AI 領域大展身手，推進整個 AI 科學技術的進展。</p>
<h2 id="ai-的夢想"><a href="#ai-的夢想">AI 的夢想</a></h2>
<p>長久以來，AI 一直是一個充滿夢幻式魅力的領域，人們對 AI 有無數的幻想與憧憬。科幻小說當中的未來世界可以說是 AI 的遠程目標。但是，我相信學術界的許多人對這個說法有很多批判。因為，夢想與科學似乎是兩個極端，科學的動力來自於夢想，但是科學的發展卻是一個排除夢想的過程。</p>
<p>盡管科幻書籍當中早已述說過這種夢想千百回了，然而，夢想仍然是夢想。要實現這些夢想，仍是一條漫漫長路。或許，在我們有生之年，都還看不到下列情況，但是，這些想像中的情節卻不斷的吸引著 AI 研究者踏入這個領域。讓我們以一個科幻小說式的場景說明這些 AI 的目標。</p>
<p>『西元 2100 年，史丹利從家中起床，在吃完僕人瑪莉 (一個機器人) 所準備的早餐之後，開著智慧型的汽車 (名為夥計)，前往他上班的地點，MIT 的媒體實驗室。與其說史丹利在開車，不如說他在車上繼續睡覺。因為，夥計早就知道他上班的地點，因此，直接開到MIT 的媒體實驗室後，用鬧鈴叫史丹利第二次起床，然後，自動開門讓史丹利進入 MIT 媒體實驗室的大門。</p>
<p>在進入大門之後，媒體實驗室的助理莉莎 (另一個機器人) 告訴史丹利，今天有一位中國籍學者 – 江明來訪，打算與史丹利談談有關最近虛擬駭客入侵 MIT 虛擬世界，偷走巨額虛擬貨幣的事情。當學者江明到達時，說了一句『史丹利先生，您好!』，然後，江明嘴邊的懸浮式透明麥克風，立刻將這句話翻譯成英文的 “Hello ! Mr. Stanly，Nice to meet you !” 傳送給史丹利耳中的訊息接收機，然後在史丹利先生的耳中播放出來。因此，雖然史丹利先生並不懂中文，但是，卻可以與江明先生侃侃而談。…』</p>
<p>我們有必要就此停止故事情節繼續發展下去，因為，再寫下去這本書就變成科幻小說了。請讀者回到 21 世紀初的現在，回到人工智慧教科書的主題中。如果我們想要實現上述的未來，那麼，我們到底現在應該要做甚麼呢？讓我們逐項分析看看。</p>
<p>瑪莉 (機器人) 會做早餐，因此，他應該會移動、開冰箱、拿菜、開瓦斯、煮菜、拿碗、裝菜、上菜等動作。為了達成這些動作，瑪莉必須有控制其手腳的能力，這是典型的機器人控制問題。瑪莉應該也需要具備視覺感官與影像辨識的能力，以避免發生撞到東西、煮菜時過熟烤焦等問題。同樣的，夥計 (智慧型汽車) 也必須具備視覺辨識能力，以避免開車時撞到東西，並且能正確的將車開到 MIT 媒體實驗室。莉莎 (機器人助理) 需要具備記憶力與語音合成的能力，以告訴史丹利其行程表。而學者江明嘴邊的懸浮式透明麥克風，則需要具備語音識別與英漢自動翻譯技術，才能將中文的語音，轉換成英文的句子，傳送給史丹利先生耳中的訊息接收機。而這台訊息接收機，則必須具備語音合成的能力，才能將這些訊息，轉成語音撥放到史丹利先生的耳內，這些訊息甚至可能包含腔調與口音，才能讓這個同步翻譯過程更為逼真流暢。</p>
<p>但是，我們必須先向讀者說聲抱歉，因為，這只是一段科幻場景，這些技術，我們現在通通都沒有。這些夢幻式的能力，全都還在人類的想像當中。雖然，AI 學術界已經做了五十年以上的研究，然而，我們的影像辨識、語音識別、機器人控制、自然語言理解、機器翻譯等技術，幾乎全都還無法在現實生活上派上用場。但是，人類因為有夢想而偉大，我們仍然必須努力的作著這些夢，不管未來何時會實現，或者會不會實現，就像周星馳的名言 - 『沒有夢想，那人活著和狗有甚麼不同』，或者更加激勵人心的佐賀阿嘛的一句話 - 『有夢想總比沒夢想好，就算到死的時候都還無法實現也沒有關係。因為，那不過是個夢想而已』。</p>
<h1 id="爬山演算法"><a href="#爬山演算法">爬山演算法</a></h1>
<p>爬山演算法 (Hill Climbing) 是一種最簡單的優化算法，該方法就像模擬人類爬山時的行為而設計的，因此稱為爬山演算法。</p>
<p>程式究竟要怎麼爬山呢？且讓我們用一張圖來看看。</p>
<p>假如我們在 Google 裏輸入一個算式，Google 會幫我們畫出該函數。舉例而言，如果我在 Google 輸入 <code>x^2+3x+5</code> 這個算式，您會看到下列圖形：</p>
<div class="figure">
<img src="../img/GoogleGraph2D.jpg" alt="圖、在 Google 輸入 x^2+3x+5 後顯示的函數圖" /><p class="caption">圖、在 Google 輸入 x^2+3x+5 後顯示的函數圖</p>
</div>
<p>這時您可以移動滑鼠，圖形會出現一個可移動的小藍點，該點會沿著曲線移動，上圖中 (x, y) 座標顯示為 x:6.07202181, y:60.0855143， 就是那個小藍點所在的位置。</p>
<p>如果我們想要寫程式尋找這個函數的最低點，那我們應該怎麼找呢？</p>
<p>其實方法很簡單，就是一直往低的地方走，一直走到最低點，然後你會看到左右兩邊都沒辦法更低了，於是就停止尋找，傳回該最低點作為答案。</p>
<p>這個方法，就像是水往低處流一樣，不斷的往更低的方向流，最後一定會流到一個山谷，然後就積成一個湖了。</p>
<p>但是、既然這樣，那為甚麼叫做爬山演算法，而不叫「流水下山演算法」呢？</p>
<p>其實、只要反過來看就行了，如果我們想要找的是最高點，而不是最低點，那整個行為就會像爬山一樣，只是最後爬到山頂就會停了。</p>
<p>採用這種想法，若我們想找 <img src="../timg/b2a89b129682.jpg" /> 這個函數的最高，我們可以在 Google 輸入 <code>-(x^2+3x+5)</code> 就可以看到那座山了，以下是 Google 顯示的結果：</p>
<div class="figure">
<img src="../img/GoogleGraph2DMountain.jpg" alt="圖、在 Google 輸入 -(x^2+3x+5) 後顯示的函數圖" /><p class="caption">圖、在 Google 輸入 -(x^2+3x+5) 後顯示的函數圖</p>
</div>
<p>當然、如果函數有很多山峰，那這種方法只能走到小山丘就會停了。這時您可能會說，那為甚麼不再繼續往更高的山走去呢？</p>
<p>關於這點，並不是不行，只是程式沒有眼睛，也沒辦法一眼望去把所有的地形都給看光，然後知道更高的山峰在哪裡？</p>
<p>如果我們用上面水往低處流的想法，您就會清楚爬山演算法所遭遇的困難了。當您像水一樣往下流，到了谷底之後，由於四周都是山壁，所以您根本看不到更低的谷到底在哪裡，所以只好就停下來了。</p>
<p>此時、除非你爬出山谷，否則根本不可能找到更深的谷，這就是「流水下山演算法」所遭遇到的困難了。以下是我們用 Google 顯示 <code>(x-5)*(x-3)*(2x+5)*(x+3)</code> 這個具有兩個山谷的函數，所得到的圖形。</p>
<div class="figure">
<img src="../img/GoogleGraph2D2vally.jpg" alt="圖、兩個山谷的情況，如何找到最低的山谷呢？" /><p class="caption">圖、兩個山谷的情況，如何找到最低的山谷呢？</p>
</div>
<p>假如我們在上圖中左邊的山谷，那麼怎麼能知道右邊還有一個更低的山谷呢？這就是「流水下山演算法」的困難之所在了！</p>
<p>當然、也有人試圖提出一些企圖找到更深的谷，或爬到更高的山的演算法，這些演算法往往是以爬山演算法為基礎，然後再作一些改良，像是「模擬退火演算法」(Simulated Annealing Algorithm) 或大洪水演算法 (Great Deluge algorithm) 等等，這些方法都是企圖讓「流水下山演算法」有機會跳出山谷而設計的方法。</p>
<p>當然、您也可以企圖加上「衝力」之類的想法讓「流水下山演算法」可以衝出低谷，但是到底要衝多久，還有該往哪個方向衝才對呢？那這種方法是否該改叫「衝山演算法」呢？</p>
<p>當然、我是沒有聽過這種名稱啦！</p>
<p>另外、對於上述的單變數函數而言，不是往左邊走就是往右邊走，但是如果有兩個變數，例如像 <code>x^2+y^2+3x+5y+6</code> ，但是只有一個山谷，那麼我們該修改哪個變數呢？舉例而言，以下就是 Google 所畫出的 <code>x^2+y^2+3x+5y+6</code> 之圖形。</p>
<div class="figure">
<img src="../img/GoogleGraph3D.jpg" />
</div>
<p>在上述的雙變數情形中，我們可以隨機的挑一個變數，然後向左或向右移動一小步，只要移動後的點更低就接受，如果連續很多次移動都沒辦法找到更低的點，就認為已經到達山谷，這樣的方法其實還蠻有效的，這種方法可以稱為「隨機下山演算法」 (反過來英文中以爬山的角度來看，所以稱為隨機爬山演算法 Stochastic Hill Climbing Algorithm)。</p>
<p>當然、隨機的方法有時會比較沒效率，如果我們可以很容易的透過微積分計算斜率 (導數) 的話，那麼不管幾個變數，我們都可以計算出山坡上最陡峭的那一個方向，這種微積分概念稱為「梯度」，如下圖所示：</p>
<div class="figure">
<img src="../img/Gradient.jpg" alt="圖、曲面與每一點的梯度向量" /><p class="caption">圖、曲面與每一點的梯度向量</p>
</div>
<p>在上圖中，底下的平面上所畫的向量，就是上面那個曲面在該點的梯度，換句話說某一點的梯度其實是一個向量。梯度的計算公式如下：</p>
<div class="figure">
<img src="../timg/4d0383fdb044.jpg" />
</div>
<p>如果我們可以計算某函數之梯度的話，那麼就可以不用透過隨機的方式去亂走了，只要朝著梯度的方向走去，就是最快下降的道路了。</p>
<p>如果我們採用這種沿著梯度方向往下走的方法，就稱為「梯度下降法」(Gradient Descent)，這種方法可以說是一種「貪婪演算法」(Greedy Algorithm)，因為它每次都朝著最斜的方向走去，企圖得到最大的下降幅度。</p>
<p>在程式人雜誌上一期的焦點「神經網路」中的「反傳遞演算法」，其實就是一種梯度下降法，所以才會有下列這段程式：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">sigmoid</span>(x) {
  <span class="kw">return</span> <span class="ot">ml</span>.<span class="fu">tanh</span>(x);
}

<span class="kw">function</span> <span class="fu">dsigmoid</span>(y) {
  <span class="kw">return</span> <span class="fl">1.0</span> - y*y;
}</code></pre>
<p>其中的 sigmoid(x) 設定為 tanh(x) 這個函數，tanh(x) 的數學定義如下：</p>
<div class="figure">
<img src="../timg/0a7a7dbd3516.jpg" />
</div>
<div class="figure">
<img src="../timg/7621e383e2fc.jpg" />
</div>
<div class="figure">
<img src="../timg/fb1e12546ddc.jpg" />
</div>
<p>而 dsigmoid(y) 中的 <code>1.0 - y*y</code> 則是 y=tanh(x) 的微分式，對每個 y=tanh(x) 都取微分式的時候，其實就是梯度的方向，因此「反傳遞演算法」事實上是一種梯度下降法啊！</p>
<p>這時，或許各位會想起，「貪婪演算法」怎麼感覺有點熟悉，似乎在哪裡學過？</p>
<p>如果各位學過演算法課程，或許想起像「最小擴展樹」(Minimal Spanning Tree) 的演算法，您會想到這種方法也很貪婪，因為每次都找最小的邊來加入，那也是一種「貪婪演算法」，但這與此處的貪婪演算法之概念顯然有些差距了。</p>
<h3 id="參考文獻"><a href="#參考文獻">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Hill-climbing">Wikipedia:Hill climbing</a></li>
<li><a href="http://en.wikipedia.org/wiki/Great_Deluge_algorithm">Wikipedia:Great Deluge algorithm</a></li>
<li><a href="http://en.wikipedia.org/wiki/Simulated_annealing">Wikipedia:Simulated annealing</a></li>
<li><a href="http://en.wikipedia.org/wiki/Stochastic_hill_climbing">Wikipedia:Stochastic hill climbing</a></li>
<li><a href="http://en.wikipedia.org/wiki/Gradient_descent">Wikipedia:Gradient descent</a></li>
<li><a href="http://en.wikipedia.org/wiki/Greedy_algorithm">Wikipedia:Greedy algorithm</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95">維基百科：爬山演算法</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB">維基百科：模擬退火</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">維基百科：梯度下降法</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">維基百科：貪心法</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作以爬山演算法尋找函數最高點"><a href="#實作以爬山演算法尋找函數最高點">實作：以爬山演算法尋找函數最高點</a></h2>
<h3 id="簡介"><a href="#簡介">簡介</a></h3>
<p>以下是「爬山演算法」 (Hill-Climbing Algorithm) 的一個簡易版本，其方法超簡單，就是一直看旁邊有沒有更好的解，如果有就移過去。然後反覆的作這樣的動作，直到旁邊的解都比現在的更差時，程式就停止，然後將那個位於山頂的解傳回，就完成了。</p>
<pre><code>Algorithm HillClimbing(f, x)
  x = 隨意設定一個解。
  while (x 有鄰居 x&#39; 比 x 更高)
    x = x&#39;;
  end
  return x;
end</code></pre>
<p>當然、這種演算法只能找到「局部最佳解」(local optimal)，當整個空間有很多山頂的時候，這種方法會爬到其中一個山頂就停了，並不一定會爬到最高的山頂。</p>
<h3 id="程式碼"><a href="#程式碼">程式碼</a></h3>
<p>檔案： HillClimbingSimple.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="kw">function</span> <span class="fu">f</span>(x) { <span class="kw">return</span> -<span class="dv">1</span>*(x*x<span class="dv">+3</span>*x<span class="dv">+5</span>); }
<span class="co">// function f(x) { return -1*Math.abs(x*x-4); }</span>

<span class="kw">var</span> dx = <span class="fl">0.01</span>;

<span class="kw">function</span> <span class="fu">hillClimbing</span>(f, x) {
  <span class="kw">while</span> (<span class="kw">true</span>) {
    <span class="fu">log</span>(<span class="st">&quot;f(%s)=%s&quot;</span>, <span class="ot">x</span>.<span class="fu">toFixed</span>(<span class="dv">4</span>), <span class="fu">f</span>(x).<span class="fu">toFixed</span>(<span class="dv">4</span>));
    <span class="kw">if</span> (<span class="fu">f</span>(x+dx) &gt;= <span class="fu">f</span>(x))
    x = x+dx;
    <span class="kw">else</span> <span class="kw">if</span> (<span class="fu">f</span>(x-dx) &gt;= <span class="fu">f</span>(x))
    x = x-dx;
    <span class="kw">else</span>
    <span class="kw">break</span>;
  }
}

<span class="fu">hillClimbing</span>(f, <span class="fl">0.0</span>);</code></pre>
<h3 id="執行結果"><a href="#執行結果">執行結果</a></h3>
<p>求解 : <img src="../timg/489e5db6d4d6.jpg" /> 的最高點，也就是 <img src="../timg/b2a89b129682.jpg" /> 的最低點。</p>
<pre><code>D:\Dropbox\Public\web\ai\code\optimize&gt;node hillClimbingSimple
f(0.0000)=-5.0000
f(-0.0100)=-4.9701
f(-0.0200)=-4.9404
f(-0.0300)=-4.9109
f(-0.0400)=-4.8816
f(-0.0500)=-4.8525
...
f(-1.4500)=-2.7525
f(-1.4600)=-2.7516
f(-1.4700)=-2.7509
f(-1.4800)=-2.7504
f(-1.4900)=-2.7501
f(-1.5000)=-2.7500</code></pre>
<p>如果我們將上述程式的 f(x) 換成註解中的那個，也就是將 f(x) 換成如下版本：</p>
<pre><code>function f(x) { return -1*Math.abs(x*x-4); }</code></pre>
<p>那麼就可以用來求解 <img src="../timg/b2cb861ede12.jpg" /> 的最低點，也就是尋找 4 的平方根，以下是執行結果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\optimize&gt;node hillClimbingSimple
f(0.0000)=-4.0000
f(0.0100)=-3.9999
f(0.0200)=-3.9996
f(0.0300)=-3.9991
f(0.0400)=-3.9984
f(0.0500)=-3.9975
...
f(1.9500)=-0.1975
f(1.9600)=-0.1584
f(1.9700)=-0.1191
f(1.9800)=-0.0796
f(1.9900)=-0.0399
f(2.0000)=-0.0000</code></pre>
<p>您可以看到上述程式正確的找到 4 的平方根是 2，而我們所用的方法與求解 <img src="../timg/489e5db6d4d6.jpg" /> 的最高點幾乎是一模一樣的，只是把函數換掉而已。</p>
<h3 id="結語"><a href="#結語">結語</a></h3>
<p>您可以看到上述用爬山演算法尋找函數最高點或最低點的程式，其實非常的簡單，只不過是看看兩邊是否有更好的解，如果有就移過去罷了。</p>
<p>但是、這麼簡單的演算法，其實威力是非常強大的，這種方法可以求解的問題非常的多，很多人工智慧上非常重要的問題，其實都只不過是在進行函數優化的動作，也就是尋找某個函數的低點或高點而已，這些問題其實大部分都可以使用爬山演算法來求解。</p>
<p>當然、要能尋找更複雜函數的「區域最佳解」，還必須進一步的對上述程式進行封裝與抽象化，我們將在下一篇文章中解說將上述爬山程式抽象化後的版本，並用該程式來求更複雜函數的解。</p>
<h3 id="參考文獻-1"><a href="#參考文獻-1">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Hill-climbing">Wikipedia:Hill climbing</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95">維基百科：爬山演算法</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作通用的爬山演算法架構"><a href="#實作通用的爬山演算法架構">實作：通用的爬山演算法架構</a></h2>
<h3 id="前言"><a href="#前言">前言</a></h3>
<p>在上一篇文章中，我們介紹了如何用 JavaScript 來尋找「單變數函數」的最高點。在這篇文章中，我們會將這個程式抽象化之後，成為一個通用的爬山演算法架構，以便能夠尋找任何函數的最高點。</p>
<h3 id="通用的爬山演算法架構"><a href="#通用的爬山演算法架構">通用的爬山演算法架構</a></h3>
<p>檔案：HillClimbing.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="kw">function</span>() {} <span class="co">// 爬山演算法的物件模版 (類別)</span>

<span class="ot">hillClimbing</span>.<span class="ot">prototype</span>.<span class="fu">run</span> = <span class="kw">function</span>(s, maxGens, maxFails) { <span class="co">// 爬山演算法的主體函數</span>
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;s=%s&quot;</span>, s); <span class="co">// 印出初始解</span>
  <span class="kw">var</span> fails = <span class="dv">0</span>;          <span class="co">// 失敗次數設為 0</span>
  <span class="co">// 當代數 gen&lt;maxGen，且連續失敗次數 fails &lt; maxFails 時，就持續嘗試尋找更好的解。</span>
  <span class="kw">for</span> (<span class="kw">var</span> gens=<span class="dv">0</span>; gens&lt;maxGens &amp;&amp; fails &lt; maxFails; gens++) {
    <span class="kw">var</span> snew = <span class="ot">s</span>.<span class="fu">neighbor</span>();           <span class="co">// 取得鄰近的解</span>
    <span class="kw">var</span> sheight = <span class="ot">s</span>.<span class="fu">height</span>();          <span class="co">// sheight=目前解的高度</span>
    <span class="kw">var</span> nheight = <span class="ot">snew</span>.<span class="fu">height</span>();       <span class="co">// nheight=鄰近解的高度</span>
    <span class="kw">if</span> (nheight &gt;= sheight) {          <span class="co">// 如果鄰近解比目前解更好</span>
      s = snew;                        <span class="co">//   就移動過去</span>
      <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;%d: %s&quot;</span>, gens, s);  <span class="co">//   印出新的解</span>
      fails = <span class="dv">0</span>;                       <span class="co">//   移動成功，將連續失敗次數歸零</span>
    } <span class="kw">else</span>                             <span class="co">// 否則</span>
      fails++;                         <span class="co">//   將連續失敗次數加一</span>
  }
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;solution: %s&quot;</span>, s);      <span class="co">// 印出最後找到的那個解</span>
  <span class="kw">return</span> s;                            <span class="co">//   然後傳回。</span>
}

<span class="ot">module</span>.<span class="fu">exports</span> = hillClimbing;         <span class="co">// 將爬山演算法的類別匯出。</span></code></pre>
<h3 id="抽象的解答類別"><a href="#抽象的解答類別">抽象的解答類別</a></h3>
<p>檔案：solution.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Solution = <span class="kw">function</span>(v) { <span class="co">// 解答的物件模版 (類別)</span>
  <span class="kw">this</span>.<span class="fu">v</span> = v;                <span class="co">// 參數 v 為解答的資料結構</span>
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">step</span> = <span class="fl">0.01</span>;          <span class="co">// 每一小步預設走的距離</span>

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">height</span> = <span class="kw">function</span>() { <span class="co">// 爬山演算法的高度函數</span>
  <span class="kw">return</span> -<span class="dv">1</span>*<span class="kw">this</span>.<span class="fu">energy</span>();               <span class="co">// 高度 = -1 * 能量</span>
}

<span class="ot">module</span>.<span class="fu">exports</span> = Solution;   <span class="co">// 將解答類別匯出。</span></code></pre>
<h3 id="實例-1-求解平方根"><a href="#實例-1-求解平方根">實例 1 ：求解平方根</a></h3>
<p>在此，我們將以求解 4 的平方根為例，測試一下上述演算法是否能夠找到正確的解答。</p>
<p>檔案：solutionNumber.js (單變數函數，求平方根)</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Solution = <span class="fu">require</span>(<span class="st">&quot;./solution&quot;</span>);         <span class="co">// 引入解答類別</span>

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">neighbor</span> = <span class="kw">function</span>() {    <span class="co">// 單變數解答的鄰居函數。</span>
  <span class="kw">var</span> x = <span class="kw">this</span>.<span class="fu">v</span>, dx=<span class="kw">this</span>.<span class="fu">step</span>;               <span class="co">// x:解答 , dx : 移動步伐大小</span>
  <span class="kw">var</span> xnew = (<span class="ot">Math</span>.<span class="fu">random</span>() &gt; <span class="fl">0.5</span>)?x+dx:x-dx; <span class="co">// 用亂數決定向左或向右移動</span>
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(xnew);                  <span class="co">// 建立新解答並傳回。</span>
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">energy</span> = <span class="kw">function</span>() {      <span class="co">// 能量函數</span>
  <span class="kw">var</span> x = <span class="kw">this</span>.<span class="fu">v</span>;                             <span class="co">// x:解答</span>
  <span class="kw">return</span> <span class="ot">Math</span>.<span class="fu">abs</span>(x*x<span class="dv">-4</span>);                     <span class="co">// 能量函數為 |x^2-4|</span>
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {    <span class="co">// 將解答轉為字串，以供印出觀察。</span>
  <span class="kw">return</span> <span class="st">&quot;energy(&quot;</span>+<span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>)+<span class="st">&quot;)=&quot;</span>+<span class="kw">this</span>.<span class="fu">energy</span>().<span class="fu">toFixed</span>(<span class="dv">3</span>);
}

<span class="ot">module</span>.<span class="fu">exports</span> = Solution;                    <span class="co">// 將解答類別匯出。</span></code></pre>
<p>檔案：hillClimbingNumber.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="fu">require</span>(<span class="st">&quot;./hillClimbing&quot;</span>);        <span class="co">// 引入爬山演算法類別</span>
<span class="kw">var</span> solutionNumber = <span class="fu">require</span>(<span class="st">&quot;./solutionNumber&quot;</span>);    <span class="co">// 引入平方根解答類別</span>

<span class="kw">var</span> hc = <span class="kw">new</span> <span class="fu">hillClimbing</span>();                         <span class="co">// 建立爬山演算法物件</span>
<span class="co">// 執行爬山演算法 (從「解答=0.0」開始尋找, 最多十萬代、失敗一千次就跳出。</span>
<span class="ot">hc</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionNumber</span>(<span class="fl">0.0</span>), <span class="dv">100000</span>, <span class="dv">1000</span>);</code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\optimize&gt;node hillClimbingNumber.js
s=energy(0.000)=4.000
0: energy(-0.010)=4.000
2: energy(-0.020)=4.000
3: energy(-0.030)=3.999
10: energy(-0.040)=3.998
12: energy(-0.050)=3.998
....
366: energy(-1.910)=0.352
371: energy(-1.920)=0.314
375: energy(-1.930)=0.275
380: energy(-1.940)=0.236
382: energy(-1.950)=0.197
388: energy(-1.960)=0.158
389: energy(-1.970)=0.119
391: energy(-1.980)=0.080
392: energy(-1.990)=0.040
394: energy(-2.000)=0.000
solution: energy(-2.000)=0.000</code></pre>
<p>您可以看到上述程式最後找到 4 的平方根為 -2，這算是對的，因為我們在能量函數中沒有規定平方根必須是正的，如果要求要是正的，那就可以為負數加上一個懲罰函數就行了。</p>
<h3 id="實例-2-多變數函數的最佳化"><a href="#實例-2-多變數函數的最佳化">實例 2 ：多變數函數的最佳化</a></h3>
<p>在此，我們將以求解 <img src="../timg/9205615feebe.jpg" /> 這個函數的最低點，看看上述演算法對多變數函數是否能正常運作。</p>
<p>檔案：solutionArray.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Solution = <span class="fu">require</span>(<span class="st">&quot;./solution&quot;</span>);         <span class="co">// 引入抽象的解答類別</span>

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">neighbor</span> = <span class="kw">function</span>() {    <span class="co">// 多變數解答的鄰居函數。</span>
  <span class="kw">var</span> nv = <span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">slice</span>(<span class="dv">0</span>);                   <span class="co">// nv=v.clone()=目前解答的複製品</span>
  <span class="kw">var</span> i = <span class="ot">Math</span>.<span class="fu">floor</span>(<span class="ot">Math</span>.<span class="fu">random</span>()*<span class="ot">nv</span>.<span class="fu">length</span>);<span class="co">// 隨機選取一個變數</span>
  <span class="kw">if</span> (<span class="ot">Math</span>.<span class="fu">random</span>() &gt; <span class="fl">0.5</span>)                    <span class="co">// 擲骰子決定要往左或往右移</span>
    nv[i] += <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">else</span>
    nv[i] -= <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(nv);                    <span class="co">// 傳回新建的鄰居解答。</span>
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">energy</span> = <span class="kw">function</span>() {      <span class="co">// 能量函數</span>
  <span class="kw">var</span> x=<span class="kw">this</span>.<span class="fu">v</span>[<span class="dv">0</span>], y=<span class="kw">this</span>.<span class="fu">v</span>[<span class="dv">1</span>], z=<span class="kw">this</span>.<span class="fu">v</span>[<span class="dv">2</span>];
  <span class="kw">return</span> x*x<span class="dv">+3</span>*y*y+z*z<span class="dv">-4</span>*x<span class="dv">-3</span>*y<span class="dv">-5</span>*z<span class="dv">+8</span>;         <span class="co">// (x^2+3y^2+z^2-4x-3y-5z+8)</span>
}

<span class="kw">var</span> numbersToStr=<span class="kw">function</span>(array, precision) { <span class="co">// 將數字陣列轉為字串的函數。</span>
  <span class="kw">var</span> rzStr = <span class="st">&quot;&quot;</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">array</span>.<span class="fu">length</span>; i++) {
    <span class="kw">if</span> (array[i]&gt;=<span class="dv">0</span>)
      rzStr+=<span class="st">&quot; &quot;</span>+array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
    <span class="kw">else</span>
      rzStr+=array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  }
  <span class="kw">return</span> rzStr;
}


<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {    <span class="co">// 將解答轉為字串的函數，以供列印用。</span>
  <span class="kw">return</span> <span class="st">&quot;energy(&quot;</span>+<span class="fu">numbersToStr</span>(<span class="kw">this</span>.<span class="fu">v</span>, <span class="dv">3</span>)+<span class="st">&quot;)=&quot;</span>+<span class="kw">this</span>.<span class="fu">energy</span>().<span class="fu">toFixed</span>(<span class="dv">3</span>);
}

<span class="ot">module</span>.<span class="fu">exports</span> = Solution;                    <span class="co">// 將解答類別匯出。</span></code></pre>
<p>檔案： hillClimbingArray.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="fu">require</span>(<span class="st">&quot;./hillClimbing&quot;</span>);      <span class="co">// 引入爬山演算法類別</span>
<span class="kw">var</span> solutionArray = <span class="fu">require</span>(<span class="st">&quot;./solutionArray&quot;</span>);    <span class="co">// 引入多變數解答類別 (x^2+3y^2+z^2-4x-3y-5z+8)</span>

<span class="kw">var</span> hc = <span class="kw">new</span> <span class="fu">hillClimbing</span>();                       <span class="co">// 建立爬山演算法物件</span>
<span class="co">// 執行爬山演算法 (從「解答(x,y,z)=(1,1,1)」開始尋找, 最多十萬代、失敗一千次就跳出。</span>
<span class="ot">hc</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionArray</span>([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]), <span class="dv">100000</span>, <span class="dv">1000</span>);</code></pre>
<p>執行結果</p>
<pre><code>s=energy( 1.000  1.000  1.000 )=1.000
0: energy( 1.000  1.000  1.010 )=0.970
1: energy( 1.000  1.000  1.020 )=0.940
3: energy( 1.000  1.000  1.030 )=0.911
8: energy( 1.000  1.000  1.040 )=0.882
9: energy( 1.000  1.000  1.050 )=0.853
...
889: energy( 2.000  0.500  2.450 )=-2.998
894: energy( 2.000  0.500  2.460 )=-2.998
907: energy( 2.000  0.500  2.470 )=-2.999
917: energy( 2.000  0.500  2.480 )=-3.000
920: energy( 2.000  0.500  2.490 )=-3.000
924: energy( 2.000  0.500  2.500 )=-3.000
solution: energy( 2.000  0.500  2.500 )=-3.000</code></pre>
<p>您可以發現這個程式最後找到的解答是 (x, y, z)=(2, 0.5, 2.5)，其能量值為 -3，也就是高度值為 3。</p>
<h3 id="實例-3-線性聯立方程組求解"><a href="#實例-3-線性聯立方程組求解">實例 3 ：線性聯立方程組求解</a></h3>
<p>本範例求解的線性聯立方程組，可以用矩陣描述如下：</p>
<div class="figure">
<img src="../timg/c7c64bbfca16.jpg" />
</div>
<p>這種線性聯立方程組，可以寫為矩陣相乘的形式如下：</p>
<div class="figure">
<img src="../timg/fb18212e251c.jpg" />
</div>
<p>其中的 A 為矩陣、x 與 b 均為「列向量」。</p>
<div class="figure">
<img src="../timg/121a89b66301.jpg" />
</div>
<p>這類問題想要求的答案是 x 的值，也就是在 A 與 b 都已知的情況之下，求符合條件的 x 是多少？</p>
<p>我們使用的測試範例如下：</p>
<pre><code>A=[[1,1],[1,-1]]
B=[[5][1]]</code></pre>
<p>也就是求下列方程組的解答。</p>
<pre><code>x1+x2=5
x1-x2=1</code></pre>
<p>以下是我們表示解答的程式碼，其中引入了 matrix 這個矩陣相乘的函式庫。</p>
<p>檔案：solutionEquations.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Matrix   = <span class="fu">require</span>(<span class="st">&quot;./matrix&quot;</span>);
<span class="kw">var</span> Solution = <span class="fu">require</span>(<span class="st">&quot;./solution&quot;</span>);         <span class="co">// 引入抽象的解答類別</span>

<span class="co">// A X = B ，求 X 是多少？  </span>
<span class="co">// A=[[1,1],[1,-1]] B=[[5][1]]，也就是求：</span>
<span class="co">//   x1+x2=5</span>
<span class="co">//   x1-x2=1</span>
<span class="co">// 的解答</span>

<span class="kw">var</span> A = <span class="kw">new</span> <span class="fu">Matrix</span>([[<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,-<span class="dv">1</span>]]);
<span class="kw">var</span> B = <span class="kw">new</span> <span class="fu">Matrix</span>([[<span class="dv">5</span>,<span class="dv">1</span>]]).<span class="fu">transpose</span>();

<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="ot">Solution</span>.<span class="fu">zero</span> = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(<span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>));
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">neighbor</span> = <span class="kw">function</span>() {    <span class="co">// 多變數解答的鄰居函數。</span>
  <span class="kw">var</span> nx = <span class="kw">new</span> <span class="fu">Matrix</span>(<span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">m</span>);              <span class="co">// 複製目前解的矩陣</span>
  <span class="kw">var</span> i = <span class="ot">Math</span>.<span class="fu">floor</span>(<span class="ot">Math</span>.<span class="fu">random</span>()*<span class="ot">nx</span>.<span class="fu">rows</span>());<span class="co">// 隨機選取一個變數</span>
  <span class="kw">if</span> (<span class="ot">Math</span>.<span class="fu">random</span>() &gt; <span class="fl">0.5</span>)                    <span class="co">// 擲骰子決定要往左或往右移</span>
    <span class="ot">nx</span>.<span class="fu">m</span>[i][<span class="dv">0</span>] += <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">else</span>
    <span class="ot">nx</span>.<span class="fu">m</span>[i][<span class="dv">0</span>] -= <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(nx);                    <span class="co">// 傳回新建的鄰居解答。</span>
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">energy</span> = <span class="kw">function</span>() {      <span class="co">// 能量函數:計算 ||AX-B||，也就是 ||Y-B||</span>
  <span class="kw">var</span> X = <span class="kw">this</span>.<span class="fu">v</span>;
  <span class="kw">var</span> Y = <span class="ot">A</span>.<span class="fu">mul</span>(X);
  <span class="kw">return</span> <span class="ot">Y</span>.<span class="fu">sub</span>(B).<span class="fu">norm</span>();
}

<span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {    <span class="co">// 將解答轉為字串的函數，以供列印用。</span>
  <span class="kw">return</span> <span class="st">&quot;energy(&quot;</span>+<span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">transpose</span>().<span class="fu">toString</span>().<span class="fu">replace</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;&quot;</span>)+<span class="st">&quot;)=&quot;</span>+<span class="kw">this</span>.<span class="fu">energy</span>().<span class="fu">toFixed</span>(<span class="dv">3</span>);
}

<span class="ot">module</span>.<span class="fu">exports</span> = Solution;                    <span class="co">// 將解答類別匯出。</span></code></pre>
<p>接著是爬山演算法的主體，我們從解答 <code>x=[0,0]</code> 開始尋找：</p>
<p>檔案：hillClimbingEquations.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="fu">require</span>(<span class="st">&quot;./hillClimbing&quot;</span>);      <span class="co">// 引入爬山演算法類別</span>
<span class="kw">var</span> solutionEquations = <span class="fu">require</span>(<span class="st">&quot;./solutionEquations&quot;</span>);    <span class="co">// 引入線性聯立方程組解答類別</span>

<span class="kw">var</span> hc = <span class="kw">new</span> <span class="fu">hillClimbing</span>();                       <span class="co">// 建立爬山演算法物件</span>
<span class="co">// 執行爬山演算法 (從「解答 x=(0,0)」開始尋找, 最多十萬代、失敗一千次就跳出。</span>
<span class="ot">hc</span>.<span class="fu">run</span>(<span class="ot">solutionEquations</span>.<span class="fu">zero</span>(), <span class="dv">100000</span>, <span class="dv">1000</span>);</code></pre>
<p>最後我們列出整個矩陣相乘的函數庫原始碼：</p>
<p>檔案：matrix.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="kw">var</span> Matrix=<span class="kw">function</span>(mat) {
  <span class="kw">var</span> m = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">mat</span>.<span class="fu">length</span>; i++) {
    m[i] = mat[i].<span class="fu">slice</span>(<span class="dv">0</span>);
  }
  <span class="kw">this</span>.<span class="fu">m</span> = m;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">precision</span> = <span class="dv">3</span>;

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">toStr</span>=<span class="kw">function</span>(precision) {
  <span class="kw">var</span> rzStr = <span class="st">&quot;&quot;</span>, m = <span class="kw">this</span>.<span class="fu">m</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++) {
    <span class="kw">var</span> rowStr = <span class="st">&quot;&quot;</span>
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
      rowStr += m[i][j].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
    rzStr += <span class="st">&quot;[&quot;</span>+<span class="ot">rowStr</span>.<span class="fu">trim</span>()+<span class="st">&quot;]</span><span class="ch">\n</span><span class="st">&quot;</span>;
  }
  <span class="kw">return</span> rzStr;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">rows</span>=<span class="kw">function</span>() { <span class="kw">return</span> <span class="kw">this</span>.<span class="ot">m</span>.<span class="fu">length</span>; }
<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">cols</span>=<span class="kw">function</span>() { <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">m</span>[<span class="dv">0</span>].<span class="fu">length</span>; }
<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">toString</span>=<span class="kw">function</span>() { <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">toStr</span>(<span class="kw">this</span>.<span class="fu">precision</span>); }

<span class="ot">Matrix</span>.<span class="fu">create</span>=<span class="kw">function</span>(rows, cols, value) {
  <span class="kw">var</span> m = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;rows; i++) {
    m[i] = [];
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;cols; j++)
      m[i][j] = value;
  }
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Matrix</span>(m);
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">transpose</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> m = <span class="kw">this</span>.<span class="fu">m</span>;
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(m[<span class="dv">0</span>].<span class="fu">length</span>, <span class="ot">m</span>.<span class="fu">length</span>, <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++) {
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>;j++)
      <span class="ot">r</span>.<span class="fu">m</span>[j][i] = m[i][j];
  }
  <span class="kw">return</span> r;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">mul</span>=<span class="kw">function</span>(mat2) {
  <span class="kw">var</span> m = <span class="kw">this</span>.<span class="fu">m</span>, m2=<span class="ot">mat2</span>.<span class="fu">m</span>;
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="ot">m</span>.<span class="fu">length</span>, m2[<span class="dv">0</span>].<span class="fu">length</span>, <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++)
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++) 
      <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;m2[j].<span class="fu">length</span>; k++)
        <span class="ot">r</span>.<span class="fu">m</span>[i][k] += m[i][j]*m2[j][k];
  <span class="kw">return</span> r;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">add</span>=<span class="kw">function</span>(mat2) {
  <span class="kw">var</span> m = <span class="kw">this</span>.<span class="fu">m</span>, m2 = <span class="ot">mat2</span>.<span class="fu">m</span>;
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="ot">m</span>.<span class="fu">length</span>, m[<span class="dv">0</span>].<span class="fu">length</span>, <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++)
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
      <span class="ot">r</span>.<span class="fu">m</span>[i][j] = m[i][j]+m2[i][j];
  <span class="kw">return</span> r;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">sub</span>=<span class="kw">function</span>(mat2) {
  <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">add</span>(<span class="ot">mat2</span>.<span class="fu">neg</span>());
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">sum</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> s=<span class="dv">0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++)
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
      s += m[i][j];
  <span class="kw">return</span> s;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">norm</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> s=<span class="dv">0</span>, m=<span class="kw">this</span>.<span class="fu">m</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++)
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
      s += m[i][j]*m[i][j];
  <span class="kw">return</span> s;
}

<span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">neg</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="kw">this</span>.<span class="fu">rows</span>(), <span class="kw">this</span>.<span class="fu">cols</span>(), <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">r</span>.<span class="ot">m</span>.<span class="fu">length</span>; i++)
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="ot">r</span>.<span class="fu">m</span>[i].<span class="fu">length</span>; j++)
      <span class="ot">r</span>.<span class="fu">m</span>[i][j] = -<span class="dv">1</span>*<span class="kw">this</span>.<span class="fu">m</span>[i][j];
  <span class="kw">return</span> r;
}

<span class="ot">Matrix</span>.<span class="fu">test</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> m1=<span class="kw">new</span> <span class="fu">Matrix</span>([[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]);
  <span class="kw">var</span> m2=<span class="ot">m1</span>.<span class="fu">transpose</span>();
  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">precision</span> = <span class="dv">0</span>;
  <span class="fu">log</span>(<span class="st">&quot;=====m1========</span><span class="ch">\n</span><span class="st">%s&quot;</span>, m1);
  <span class="fu">log</span>(<span class="st">&quot;=====m2========</span><span class="ch">\n</span><span class="st">%s&quot;</span>, m2);
  <span class="fu">log</span>(<span class="st">&quot;=====m1+m1=====</span><span class="ch">\n</span><span class="st">%s&quot;</span>, <span class="ot">m1</span>.<span class="fu">add</span>(m1));
  <span class="fu">log</span>(<span class="st">&quot;=====m1*m2=====</span><span class="ch">\n</span><span class="st">%s&quot;</span>, <span class="ot">m1</span>.<span class="fu">mul</span>(m2));
}

<span class="co">// Matrix.test();</span>

<span class="ot">module</span>.<span class="fu">exports</span> = Matrix;</code></pre>
<p>執行結果如下：</p>
<pre><code>s=energy([0.000 0.000])=26.000
1: energy([0.000 0.010])=25.920
5: energy([0.000 0.020])=25.841
6: energy([0.000 0.030])=25.762
7: energy([0.000 0.040])=25.683
9: energy([0.010 0.040])=25.563
...
655: energy([1.600 1.760])=4.035
656: energy([1.600 1.770])=4.026
659: energy([1.610 1.770])=3.970
660: energy([1.620 1.770])=3.915
661: energy([1.630 1.770])=3.860
664: energy([1.640 1.770])=3.805
665: energy([1.640 1.780])=3.796
666: energy([1.640 1.790])=3.787
...
1176: energy([2.970 2.000])=0.002
1184: energy([2.980 2.000])=0.001
1197: energy([2.990 2.000])=0.000
1205: energy([3.000 2.000])=0.000
solution: energy([3.000 2.000])=0.000</code></pre>
<p>您可以看到最後找到的解為 <code>x=[3, 2]</code> ，這個結果確實是下列方程組的解答：</p>
<pre><code>x1+x2=5
x1-x2=1</code></pre>
<p>於是我們用這個爬山演算法的架構解決了線性聯立方程組的求解問題。</p>
<h3 id="結語-1"><a href="#結語-1">結語</a></h3>
<p>當然、上述的架構不只可以解這些問題，甚至可以用來解像「線性規劃、神經網路優化....」等等各式各樣的問題，前提是您必須自行設計 solution 類別的 neighbor(), energy() 與 toString() 函數，然後寫個主程式呼叫爬山演算法就行了。</p>
<h3 id="參考文獻-2"><a href="#參考文獻-2">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Hill-climbing">Wikipedia:Hill climbing</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95">維基百科：爬山演算法</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作通用的模擬退火法架構"><a href="#實作通用的模擬退火法架構">實作：通用的「模擬退火法」架構</a></h2>
<h3 id="前言-1"><a href="#前言-1">前言</a></h3>
<p>在上一篇文章中，我們介紹了一個通用的爬山演算法架構，而模擬退火法其實是爬山演算法的一個改良版，其設計理念是參考打鐵時金屬從高溫逐漸緩慢降溫，可以讓結構更緊緻的這種概念，在「流水下山演算法」上加入了溫度的概念。</p>
<p>當溫度很高的時候，模擬退火法基本上就像隨機亂走一樣，但是當溫度逐漸下降之後，模擬退火法就會逐漸凝固，只能朝著較好的解前進，向著較差解前進的機率會逐漸縮小。</p>
<p>當溫度幾乎降到零的時候，模擬退火法基本上就會退化成爬山演算法，於是最後還是會固定在某個「區域最佳解」上面。但是由於經過從高溫緩慢降溫的過程，所以模擬退火法比較有機會在高溫時跳出區域最佳解，然後找到更好的解，甚至是全域最佳解之後才凝固，這就是「模擬退火法」的設計原理了。</p>
<p>以下是模擬退火法的演算法的簡要寫法：</p>
<pre><code>Algorithm SimulatedAnnealing(s)
  while (溫度還不夠低，或還可以找到比 s 更好的解 s&#39; 的時候)
    根據能量差與溫度，用機率的方式決定是否要移動到新解 s&#39;。
    將溫度降低一些
  end
end  </code></pre>
<p>在上述演算法中，所謂的機率的方式，是採用 <img src="../timg/658cc096866d.jpg" /> 這個機率公式，去判斷是否要從 s 移動到 s'，其中 e 是 s 的能量值，而 e' 是 s' 的能量值。</p>
<p>接著，就讓我們來實作一個通用的模擬退火法架構吧 (與前述爬山演算法共用的「解答表示」solution 部份，我們就不再重複貼出了)</p>
<h3 id="通用的模擬退火法架構"><a href="#通用的模擬退火法架構">通用的模擬退火法架構</a></h3>
<p>檔案：simulatedAnnealing.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> simulatedAnnealing = <span class="kw">function</span>() {}       <span class="co">// 模擬退火法的物件模版 (類別)</span>

<span class="ot">simulatedAnnealing</span>.<span class="ot">prototype</span>.<span class="fu">P</span> = <span class="kw">function</span>(e, enew, T) { <span class="co">// 模擬退火法的機率函數</span>
  <span class="kw">if</span> (enew &lt; e) 
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">else</span>
    <span class="kw">return</span> <span class="ot">Math</span>.<span class="fu">exp</span>((e-enew)/T);              
}

<span class="ot">simulatedAnnealing</span>.<span class="ot">prototype</span>.<span class="fu">run</span> = <span class="kw">function</span>(s, maxGens) { <span class="co">// 模擬退火法的主要函數</span>
  <span class="kw">var</span> sbest = s;                              <span class="co">// sbest:到目前為止的最佳解</span>
  <span class="kw">var</span> ebest = <span class="ot">s</span>.<span class="fu">energy</span>();                     <span class="co">// ebest:到目前為止的最低能量</span>
  <span class="kw">var</span> T     = <span class="dv">100</span>;                            <span class="co">// 從 100 度開始降溫</span>
  <span class="kw">for</span> (<span class="kw">var</span> gens=<span class="dv">0</span>; gens&lt;maxGens; gens++) {    <span class="co">// 迴圈，最多作 maxGens 這麼多代。</span>
    <span class="kw">var</span> snew = <span class="ot">s</span>.<span class="fu">neighbor</span>();                  <span class="co">// 取得鄰居解</span>
    <span class="kw">var</span> e    = <span class="ot">s</span>.<span class="fu">energy</span>();                    <span class="co">// e    : 目前解的能量</span>
    <span class="kw">var</span> enew = <span class="ot">snew</span>.<span class="fu">energy</span>();                 <span class="co">// enew : 鄰居解的能量</span>
    T  = T * <span class="fl">0.999</span>;                           <span class="co">// 每次降低一些溫度</span>
    <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">P</span>(e, enew, T) &gt; <span class="ot">Math</span>.<span class="fu">random</span>()) { <span class="co">// 根據溫度與能量差擲骰子，若通過</span>
      s = snew;                               <span class="co">// 則移動到新的鄰居解</span>
      <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;%d T=%s %s&quot;</span>, gens, <span class="ot">T</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>), <span class="ot">s</span>.<span class="fu">toString</span>()); <span class="co">// 印出觀察</span>
    }
    <span class="kw">if</span> (enew &lt; ebest) {                       <span class="co">// 如果新解的能量比最佳解好，則更新最佳解。</span>
      sbest = snew;
      ebest = enew;
    }
  }
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;solution: %s&quot;</span>, <span class="ot">sbest</span>.<span class="fu">toString</span>()); <span class="co">// 印出最佳解</span>
  <span class="kw">return</span> sbest;                                  <span class="co">// 傳回最佳解</span>
}

<span class="ot">module</span>.<span class="fu">exports</span> = simulatedAnnealing;             <span class="co">// 將模擬退火演算法的類別匯出。</span></code></pre>
<h3 id="實例求解平方根"><a href="#實例求解平方根">實例：求解平方根</a></h3>
<p>在此，我們將以求解 4 的平方根為例，測試一下上述演算法是否能夠找到正確的解答。</p>
<p>檔案：simulatedAnnealingNumber.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> simulatedAnnealing = <span class="fu">require</span>(<span class="st">&quot;./simulatedAnnealing&quot;</span>); <span class="co">// 引入模擬退火法類別</span>
<span class="kw">var</span> solutionNumber = <span class="fu">require</span>(<span class="st">&quot;./solutionNumber&quot;</span>);         <span class="co">// 引入平方根解答類別</span>

<span class="kw">var</span> sa = <span class="kw">new</span> <span class="fu">simulatedAnnealing</span>();                        <span class="co">// 建立模擬退火法物件</span>
<span class="co">// 執行模擬退火法 (從「解答=0.0」開始尋找, 最多一萬代。</span>
<span class="ot">sa</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionNumber</span>(<span class="fl">0.0</span>), <span class="dv">10000</span>);</code></pre>
<p>執行結果：</p>
<pre><code>0 T=99.900 energy(-0.010)=4.000
1 T=99.800 energy(0.000)=4.000
...
12 T=98.708 energy(-0.010)=4.000
13 T=98.609 energy(-0.020)=4.000
14 T=98.510 energy(-0.030)=3.999
15 T=98.412 energy(-0.020)=4.000
16 T=98.314 energy(-0.030)=3.999
17 T=98.215 energy(-0.040)=3.998
18 T=98.117 energy(-0.050)=3.998
19 T=98.019 energy(-0.040)=3.998
...
5072 T=0.625 energy(1.250)=2.437
5073 T=0.624 energy(1.240)=2.462
5074 T=0.624 energy(1.230)=2.487
5075 T=0.623 energy(1.240)=2.462
5076 T=0.622 energy(1.250)=2.437
5077 T=0.622 energy(1.260)=2.412
5078 T=0.621 energy(1.270)=2.387
5079 T=0.620 energy(1.280)=2.362
...
6615 T=0.133 energy(1.950)=0.197
6617 T=0.133 energy(1.940)=0.236
6618 T=0.133 energy(1.930)=0.275
6619 T=0.133 energy(1.920)=0.314
6620 T=0.133 energy(1.930)=0.275
6621 T=0.133 energy(1.940)=0.236
6622 T=0.133 energy(1.930)=0.275
...
9377 T=0.008 energy(1.990)=0.040
9378 T=0.008 energy(2.000)=0.000
9396 T=0.008 energy(2.010)=0.040
9397 T=0.008 energy(2.000)=0.000
9528 T=0.007 energy(2.010)=0.040
9531 T=0.007 energy(2.000)=0.000
solution: energy(2.000)=0.000</code></pre>
<p>您可以看到上述模擬退火法程式，在一開始的時候幾乎都在亂走，因此浪費了很多時間，但也正是因為這種特性，模擬退火法比較有機會跳脫那些小山谷，而有機會找到更深的山谷，這正式模擬退火法的特性。</p>
<p>雖然花的比較多的時間，但是模擬退火法最後還是正確的找到了 4 的平方根，傳回了 2.000 的結果。</p>
<h3 id="實例多變數函數的最佳化"><a href="#實例多變數函數的最佳化">實例：多變數函數的最佳化</a></h3>
<p>在此，我們將以求解 <img src="../timg/9205615feebe.jpg" /> 這個函數的最低點，看看上述演算法對多變數函數是否能正常運作。</p>
<p>檔案：simulatedAnnealingArray.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> simulatedAnnealing = <span class="fu">require</span>(<span class="st">&quot;./simulatedAnnealing&quot;</span>); <span class="co">// 引入模擬退火法類別</span>
<span class="kw">var</span> solutionArray = <span class="fu">require</span>(<span class="st">&quot;./solutionArray&quot;</span>);           <span class="co">// 引入多變數解答類別 (x^2+3y^2+z^2-4x-3y-5z+8)</span>

<span class="kw">var</span> sa = <span class="kw">new</span> <span class="fu">simulatedAnnealing</span>();                        <span class="co">// 建立模擬退火法物件</span>
<span class="co">// 執行模擬退火法 (從「解答(x,y,z)=(1,1,1)」開始尋找, 最多執行 2 萬代。</span>
<span class="ot">sa</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionArray</span>([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]), <span class="dv">20000</span>);</code></pre>
<p>執行結果：</p>
<pre><code>0 T=99.900 energy( 1.000  1.000  0.990 )=1.030
1 T=99.800 energy( 1.000  0.990  0.990 )=1.000
2 T=99.700 energy( 1.000  0.980  0.990 )=0.971
3 T=99.601 energy( 0.990  0.980  0.990 )=0.991
4 T=99.501 energy( 0.990  0.990  0.990 )=1.021
5 T=99.401 energy( 1.000  0.990  0.990 )=1.000
6 T=99.302 energy( 1.000  0.990  1.000 )=0.970
...
5985 T=0.251 energy( 0.870  1.260  1.770 )=0.543
5986 T=0.250 energy( 0.870  1.250  1.770 )=0.497
5987 T=0.250 energy( 0.870  1.250  1.760 )=0.512
5988 T=0.250 energy( 0.870  1.250  1.750 )=0.527
5989 T=0.250 energy( 0.870  1.250  1.760 )=0.512
5990 T=0.249 energy( 0.860  1.250  1.760 )=0.535
...
15036 T=0.000 energy( 2.000  0.500  2.510 )=-3.000
15038 T=0.000 energy( 2.000  0.500  2.500 )=-3.000
15173 T=0.000 energy( 2.010  0.500  2.500 )=-3.000
15174 T=0.000 energy( 2.000  0.500  2.500 )=-3.000
15261 T=0.000 energy( 2.000  0.500  2.490 )=-3.000
15265 T=0.000 energy( 2.000  0.500  2.500 )=-3.000
solution: energy( 2.000  0.500  2.500 )=-3.000</code></pre>
<p>您可以看到，上述的模擬退火法程式，總共花了一萬五千多代，終於找到了該多變數函數的谷底，雖然速度不快，但也總算是達成任務了。</p>
<h3 id="結語-2"><a href="#結語-2">結語</a></h3>
<p>當然，模擬退火法雖然比較有機會跳脫小山谷，去找到更深的山谷，但這並不表示模擬退火法一定可以找到最深的山谷。</p>
<p>當溫度已經降到很低的時後，模擬退火法就會逐漸凝固，於是就會固定在某個山谷不出來了。</p>
<p>事實上、沒有任何一種優化方法可以在「多項式時間內」保證找到任何函數的最低點，否則「NP-Complete」問題不就被解掉了，而「NP-Complete」問題事實上在計算理論領域裡，一直還是個最困難的未解之謎啊！</p>
<h3 id="參考文獻-3"><a href="#參考文獻-3">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Simulated_annealing">Wikipedia:Simulated annealing</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB">維基百科：模擬退火</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h1 id="神經網路簡介"><a href="#神經網路簡介">神經網路簡介</a></h1>
<p>在電腦領域，神經網路是指一種模擬神經系統所設計出來的程式，用來模擬人類視覺、聽覺等等智慧行為的原理，企圖讓電腦可以具有人類智慧的一種方法。</p>
<p>下圖是生物神經細胞的結構圖，這個圖看來頗為複雜，如果電腦程式真的要模擬這麼複雜的結構，那程式應該也會非常複雜才對。</p>
<div class="figure">
<img src="../img/NeuralCell.jpg" alt="圖、神經細胞的結構" /><p class="caption">圖、神經細胞的結構</p>
</div>
<p>還好、神經網路程式不需要去模擬「細胞膜、粒線體、核醣體」等等複雜的結構，因為學電腦的人可以透過「抽象化」這個伎倆，將上述的神經細胞結構簡化成下圖 (a) 的樣子。</p>
<p>在下圖中，a1 ... an 是輸入，w1 ... wn 是權重，這些輸入乘上權重之後加總(SUM)，就會得到神經元的刺激強度，接著經過函數 f() 轉換之後，就得到了輸出的刺激強度。</p>
<div class="figure">
<img src="../img/NeuralNet1.jpg" alt="圖、神經網路連接模型" /><p class="caption">圖、神經網路連接模型</p>
</div>
<p>上圖 (a)所對應的數學公式如下：</p>
<div class="figure">
<img src="../timg/5ced75ffc852.jpg" />
</div>
<p>其中的 b 值是用來作為門檻的閥值，舉例而言，若 b 是 -0.5，那麼就代表要將總合減掉 0.5，才得到輸入刺激強度，這可以用來調節刺激強度，才不會一直增強上去。</p>
<p>而上圖 (b) 中的網路，是一種單層的神經網路，所謂單層是不計算輸入節點的計算方式，因此只有圖中的大圈圈才算是一層，其中每個大圈圈都是如圖 (a) 中的一個神經元。</p>
<p>最早的神經網路程式稱為感知器（Perceptron），這是由 Frank Rosenblatt 在 1957 年於 Cornell 航空實驗室 (Cornell Aeronautical Laboratory) 所發明的。</p>
<p>但是在 1969 年，Marvin Minsky 和 Seymour Papert 在《Perceptrons》書中，仔細分析了知器為的功能及局限，證明感知器不能解決簡單的 XOR 等問題，結果導致神經網路技術經歷了長達 20 年的低潮期。</p>
<p>後來在 1986 年，Rumelhart 等人於下列論文中提出「反向傳播」(back-propagation) 演算法，並成功的被運用在語音辨識等領域之後，神經網路才又開始成為熱門的研究主題。</p>
<blockquote>
<p>Rumelhart, David E.; Hinton, Geoffrey E., Williams, Ronald J. Learning representations by back-propagating errors. Nature. 8 October 1986, 323 (6088): 533–536.</p>
</blockquote>
<p>事實上、反向傳播的方法，並不是 Rumelhart 等人第一個提出來的，Paul J. Werbos 1974 年在哈佛的博士論文中就提出了類似的方法，只是大家都不知道而已。</p>
<blockquote>
<p>Paul J. Werbos. Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences. PhD thesis, Harvard University, 1974</p>
</blockquote>
<p>當然、神經網路再度成為研究焦點之後，各式各樣的方法又被發展出來了，大致上這些方法可以分為兩類，一種稱為「有指導者」的神經網路(Supervised Neural Network) ，像是「感知器與反傳遞演算法」等，另一種稱為「沒有指導者」的神經網路 (Unsupervised Neural Network)，像是「霍普菲爾德網路 (Hopfield Network) 與自組織神經網路 (Self Organization network)」等等。</p>
<p>當然、神經網路並不是「神奇銀彈」，可以解決人工智慧上的所有問題，神經網路最強大的地方是容錯性很強，而且不需要像專家系統這樣撰寫一堆規則，但是有一得必有一失，神經網路自動學習完成之後，我們根本不知道該如何再去改進這個學習成果，因為那些權重對人類來說根本就沒有什麼直觀的意義，因此也就很難再去改進這個網路了。</p>
<p>不過、程式能夠自我學習畢竟是一件很神奇的事情，光是這點就值得讓我們好好的去瞭解一下神經網路到底是怎麼運作的了！</p>
<h3 id="參考文獻-4"><a href="#參考文獻-4">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Neuron">Wikipedia:Neuron</a></li>
<li><a href="http://en.wikipedia.org/wiki/Artificial_neuron">Wikipedia:Artificial neuron</a></li>
<li><a href="http://en.wikipedia.org/wiki/Artificial_neural_network">Wikipedia:Artificial neural network</a></li>
<li><a href="http://en.wikipedia.org/wiki/Perceptron">Wikipedia:Perceptron</a></li>
<li><a href="http://en.wikipedia.org/wiki/Backpropagation">Wikipedia:Backpropagation</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8">維基百科：感知器</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">維基百科：人工神經網路</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E8%B5%AB%E5%B8%83%E7%90%86%E8%AE%BA">維基百科：赫布理論</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作單層感知器-perceptron"><a href="#實作單層感知器-perceptron">實作：單層感知器 (Perceptron)</a></h2>
<h3 id="簡介-1"><a href="#簡介-1">簡介</a></h3>
<p>Rosenblatt 於 1958 年提出第一個神經網路模型，稱為感知器，這個模型是基於 1943 年 McCulloch 與 Pitts 所提出的神經元模型，該模型的數學公式如下。</p>
<div class="figure">
<img src="../timg/1faa2e48aea6.jpg" />
</div>
<p>其中的 sign 是正負號判斷函數，若是正數則傳回 1，負數則傳回 0。</p>
<p>請注意，在此我們所說的「感知器」是指 Rosenblatt 當時所使用的感知器，特指只有一層節點的「單層感知器」，而不是指稱那種具有隱藏層的「多層感知器」(Multilayer Perceptron)，這點必須特別澄清一下！</p>
<p>而所謂感知器的學習，就是透過調整權重 wi 的方式，讓整個網路可以學到某個函數的方法，所以權重的調整方法是整個感知器學習行為的核心。</p>
<h3 id="感知器的學習"><a href="#感知器的學習">感知器的學習</a></h3>
<p>那麼、我們要怎麼讓神經網路學會某個函數呢？以下是感知器學習的演算法：</p>
<ol style="list-style-type: decimal">
<li><p>初始化：設定權重 <img src="../timg/c139ddae2765.jpg" /> 和臨界值 <img src="../timg/2554a2bb846c.jpg" /> 的初值之範圍為 [-0.5, 0.5]。</p></li>
<li><p>激勵：用輸入 <img src="../timg/4ec0188cd431.jpg" /> 、權重 <img src="../timg/7f0e1a55880d.jpg" /> 與閥值 <img src="../timg/2554a2bb846c.jpg" /> 計算感知器的輸出值 Y。</p>
<ul>
<li><img src="../timg/856b9cd80d94.jpg" title="fig:" /></li>
</ul></li>
<li><p>權重修改：根據函數輸出 Yd 與感知器輸出 Y 之間的差異，進行權重調整。</p>
<ul>
<li><p>3.1 計算誤差 ： <img src="../timg/49e401d40cf4.jpg" /></p></li>
<li><p>3.2 計算調整量： <img src="../timg/6fb8eb2fce33.jpg" /></p></li>
<li><p>3.3 調整權重 ： <img src="../timg/d7d825c1b95d.jpg" /></p></li>
</ul></li>
<li><p>重複 2-3 步驟，直到學會為止 (如果一直學不會，只好宣告失敗)。</p></li>
</ol>
<h3 id="感知器模型-兩個輸入的情況"><a href="#感知器模型-兩個輸入的情況">感知器模型 (兩個輸入的情況)</a></h3>
<p>根據以上的方法，假如感知器的輸入只有兩個 <img src="../timg/9fb86666733f.jpg" /> 那麼權重也只會有兩個 <img src="../timg/0a49adc5ecfb.jpg" /> ，於是我們可以得到下列的感知器模型：</p>
<div class="figure">
<img src="../img/perceptron.jpg" alt="圖、兩個輸入的感知器模型" /><p class="caption">圖、兩個輸入的感知器模型</p>
</div>
<p>假如我們的目標函數對於某組 (x1, x2) 的期望輸出為 yd，那麼就可以計算出誤差為 e=yd-y，於是我們可以透過下列方法調整權重。</p>
<div class="figure">
<img src="../timg/b1cacbe18ad7.jpg" />
</div>
<div class="figure">
<img src="../timg/deff37e6fc5a.jpg" />
</div>
<p>可惜的是、上述的調整方法中，並沒有調整到 <img src="../timg/2554a2bb846c.jpg" /> 值，如果我們想要連 <img src="../timg/2554a2bb846c.jpg" /> 值也一並設計成可浮動的，那麼就可以將 <img src="../timg/2554a2bb846c.jpg" /> 加入到 w 中，成為 w0，，並將 x0 設為 -1，如下圖所示：</p>
<div class="figure">
<img src="../img/perceptron2.jpg" alt="圖、調整簡化後的感知器模型" /><p class="caption">圖、調整簡化後的感知器模型</p>
</div>
<p>經過上述的調整簡化之後，我們只要在調整權重時加入下列這條，就可以連 <img src="../timg/2554a2bb846c.jpg" /> 也一併調整了。</p>
<div class="figure">
<img src="../timg/8e42fbb23320.jpg" />
</div>
<p>當我們對某布林函數「真值表」中的每一個輸入，都反覆進行上述調整，最後是否能學會該「布林函數」呢？</p>
<p>那麼、我們是否能夠用這麼簡單的方法讓感知器學會 AND、OR 與 XOR 函數呢？</p>
<p>如果可以的話，那麼我們能不能擴大到 n 輸入的感知器上，讓感知器學會任何一個布林函數呢？</p>
<p>如果感知器可以學會任何一個布林函數，那就會具有強大的威力了！</p>
<p>但可惜的是，這個問題的答案是否定的，雖然感知器可以學會 AND 與 OR，但是卻不可能學會 XOR 函數。</p>
<p>在說明這個問題的理論之前，先讓我們透過實作來體會一下感知器是如何學習 AND 與 OR 函數的，然後感受一下感知器在學 XOR 函數時發生了甚麼問題？</p>
<p>等到瞭解了程式的運作原理之後，我們再來說明為何感知器無法學會 XOR 函數。</p>
<h3 id="感知器實作"><a href="#感知器實作">感知器實作</a></h3>
<p>以下我們使用 JavaScript 程式實作出感知器，其程式碼如下，您可以在 node.js 環境下執行此一程式：</p>
<p>檔案：perceptron.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="kw">var</span> Perceptron = <span class="kw">function</span>() { <span class="co">// 感知器物件</span>
  <span class="kw">this</span>.<span class="fu">step</span>=<span class="kw">function</span>(x, w) { <span class="co">// 步階函數：計算目前權重 w 的情況下，網路的輸出值為 0 或 1</span>
    <span class="kw">var</span> result = w[<span class="dv">0</span>]*x[<span class="dv">0</span>]+w[<span class="dv">1</span>]*x[<span class="dv">1</span>]+w[<span class="dv">2</span>]*x[<span class="dv">2</span>]; <span class="co">// y=w0*x0+x1*w1+x2*w2=-theta+x1*w1+x2*w2</span>
    <span class="kw">if</span> (result &gt;= <span class="dv">0</span>) <span class="co">// 如果結果大於零</span>
      <span class="kw">return</span> <span class="dv">1</span>;      <span class="co">//   就輸出 1</span>
    <span class="kw">else</span>             <span class="co">// 否則</span>
      <span class="kw">return</span> <span class="dv">0</span>;      <span class="co">//   就輸出 0</span>
  }
  
  <span class="kw">this</span>.<span class="fu">training</span>=<span class="kw">function</span>(truthTable) { <span class="co">// 訓練函數 training(truthTable), 其中 truthTable 是目標真值表</span>
    <span class="kw">var</span> rate = <span class="fl">0.01</span>; <span class="co">// 學習調整速率，也就是 alpha</span>
    <span class="kw">var</span> w = [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ]; 
    <span class="kw">for</span> (<span class="kw">var</span> loop=<span class="dv">0</span>; loop&lt;<span class="dv">1000</span>; loop++) { <span class="co">// 最多訓練一千輪</span>
      <span class="kw">var</span> eSum = <span class="fl">0.0</span>;
      <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">truthTable</span>.<span class="fu">length</span>; i++) { <span class="co">// 每輪對於真值表中的每個輸入輸出配對，都訓練一次。</span>
        <span class="kw">var</span> x = [ -<span class="dv">1</span>, truthTable[i][<span class="dv">0</span>], truthTable[i][<span class="dv">1</span>] ]; <span class="co">// 輸入： x</span>
        <span class="kw">var</span> yd = truthTable[i][<span class="dv">2</span>];       <span class="co">// 期望的輸出 yd</span>
        <span class="kw">var</span> y = <span class="kw">this</span>.<span class="fu">step</span>(x, w);  <span class="co">// 目前的輸出 y</span>
        <span class="kw">var</span> e = yd - y;                  <span class="co">// 差距 e = 期望的輸出 yd - 目前的輸出 y</span>
        eSum += e*e;                     <span class="co">// 計算差距總和</span>
        <span class="kw">var</span> dw = [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ];            <span class="co">// 權重調整的幅度 dw</span>
        dw[<span class="dv">0</span>] = rate * x[<span class="dv">0</span>] * e; w[<span class="dv">0</span>] += dw[<span class="dv">0</span>]; <span class="co">// w[0] 的調整幅度為 dw[0]</span>
        dw[<span class="dv">1</span>] = rate * x[<span class="dv">1</span>] * e; w[<span class="dv">1</span>] += dw[<span class="dv">1</span>]; <span class="co">// w[1] 的調整幅度為 dw[1]</span>
        dw[<span class="dv">2</span>] = rate * x[<span class="dv">2</span>] * e; w[<span class="dv">2</span>] += dw[<span class="dv">2</span>]; <span class="co">// w[2] 的調整幅度為 dw[2]</span>
        <span class="kw">if</span> (loop % <span class="dv">10</span> == <span class="dv">0</span>)
          <span class="fu">log</span>(<span class="st">&quot;%d:x=(%s,%s,%s) w=(%s,%s,%s) y=%s yd=%s e=%s&quot;</span>, loop, 
               x[<span class="dv">0</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), x[<span class="dv">1</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), x[<span class="dv">2</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), 
               w[<span class="dv">0</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), w[<span class="dv">1</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), w[<span class="dv">2</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), 
               <span class="ot">y</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>), <span class="ot">yd</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>), <span class="ot">e</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>));
      }
      <span class="kw">if</span> (<span class="ot">Math</span>.<span class="fu">abs</span>(eSum) &lt; <span class="fl">0.0001</span>) <span class="kw">return</span> w; <span class="co">// 當訓練結果誤差夠小時，就完成訓練了。</span>
    }
    <span class="kw">return</span> <span class="kw">null</span>; <span class="co">// 否則，就傳會 null 代表訓練失敗。</span>
  }
}

<span class="kw">function</span> <span class="fu">learn</span>(tableName, truthTable) { <span class="co">// 學習主程式：輸入為目標真值表 truthTable 與其名稱 tableName。</span>
  <span class="fu">log</span>(<span class="st">&quot;================== 學習 %s 函數 ====================&quot;</span>, tableName);
  <span class="kw">var</span> p = <span class="kw">new</span> <span class="fu">Perceptron</span>();       <span class="co">// 建立感知器物件</span>
  <span class="kw">var</span> w = <span class="ot">p</span>.<span class="fu">training</span>(truthTable); <span class="co">// 訓練感知器</span>
  <span class="kw">if</span> (w != <span class="kw">null</span>)                  <span class="co">// 顯示訓練結果</span>
    <span class="fu">log</span>(<span class="st">&quot;學習成功 !&quot;</span>);
  <span class="kw">else</span>
    <span class="fu">log</span>(<span class="st">&quot;學習失敗 !&quot;</span>);
  <span class="fu">log</span>(<span class="st">&quot;w=%j&quot;</span>, w);
}

<span class="kw">var</span> andTable = [ [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span> ], [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ] ]; <span class="co">// AND 函數的真值表</span>
<span class="kw">var</span> orTable  = [ [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ] ]; <span class="co">// OR  函數的真值表</span>
<span class="kw">var</span> xorTable = [ [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span> ] ]; <span class="co">// XOR 函數的真值表</span>

<span class="fu">learn</span>(<span class="st">&quot;and&quot;</span>, andTable); <span class="co">// 學習 AND 函數</span>
<span class="fu">learn</span>(<span class="st">&quot;or&quot;</span>,  orTable);  <span class="co">// 學習 OR  函數</span>
<span class="fu">learn</span>(<span class="st">&quot;xor&quot;</span>, xorTable); <span class="co">// 學習 XOR 函數</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\ai\code&gt;node perceptron.js
================== 學習 and 函數 ====================
0:x=(-1.000,0.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
0:x=(-1.000,0.000,1.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
0:x=(-1.000,1.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
0:x=(-1.000,1.000,1.000) w=(0.990,0.010,0.010) y=0.000 yd=1.000 e=1.000
10:x=(-1.000,0.000,0.000) w=(0.900,0.100,0.100) y=0.000 yd=0.000 e=0.000
10:x=(-1.000,0.000,1.000) w=(0.900,0.100,0.100) y=0.000 yd=0.000 e=0.000
10:x=(-1.000,1.000,0.000) w=(0.900,0.100,0.100) y=0.000 yd=0.000 e=0.000
10:x=(-1.000,1.000,1.000) w=(0.890,0.110,0.110) y=0.000 yd=1.000 e=1.000
20:x=(-1.000,0.000,0.000) w=(0.800,0.200,0.200) y=0.000 yd=0.000 e=0.000
20:x=(-1.000,0.000,1.000) w=(0.800,0.200,0.200) y=0.000 yd=0.000 e=0.000
20:x=(-1.000,1.000,0.000) w=(0.800,0.200,0.200) y=0.000 yd=0.000 e=0.000
20:x=(-1.000,1.000,1.000) w=(0.790,0.210,0.210) y=0.000 yd=1.000 e=1.000
30:x=(-1.000,0.000,0.000) w=(0.700,0.300,0.300) y=0.000 yd=0.000 e=0.000
30:x=(-1.000,0.000,1.000) w=(0.700,0.300,0.300) y=0.000 yd=0.000 e=0.000
30:x=(-1.000,1.000,0.000) w=(0.700,0.300,0.300) y=0.000 yd=0.000 e=0.000
30:x=(-1.000,1.000,1.000) w=(0.690,0.310,0.310) y=0.000 yd=1.000 e=1.000
學習成功 !
w=[0.6599999999999997,0.34000000000000014,0.34000000000000014]
================== 學習 or 函數 ====================
0:x=(-1.000,0.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
0:x=(-1.000,0.000,1.000) w=(0.990,0.000,0.010) y=0.000 yd=1.000 e=1.000
0:x=(-1.000,1.000,0.000) w=(0.980,0.010,0.010) y=0.000 yd=1.000 e=1.000
0:x=(-1.000,1.000,1.000) w=(0.970,0.020,0.020) y=0.000 yd=1.000 e=1.000
10:x=(-1.000,0.000,0.000) w=(0.700,0.200,0.200) y=0.000 yd=0.000 e=0.000
10:x=(-1.000,0.000,1.000) w=(0.690,0.200,0.210) y=0.000 yd=1.000 e=1.000
10:x=(-1.000,1.000,0.000) w=(0.680,0.210,0.210) y=0.000 yd=1.000 e=1.000
10:x=(-1.000,1.000,1.000) w=(0.670,0.220,0.220) y=0.000 yd=1.000 e=1.000
20:x=(-1.000,0.000,0.000) w=(0.460,0.340,0.340) y=0.000 yd=0.000 e=0.000
20:x=(-1.000,0.000,1.000) w=(0.450,0.340,0.350) y=0.000 yd=1.000 e=1.000
20:x=(-1.000,1.000,0.000) w=(0.440,0.350,0.350) y=0.000 yd=1.000 e=1.000
20:x=(-1.000,1.000,1.000) w=(0.440,0.350,0.350) y=1.000 yd=1.000 e=0.000
學習成功 !
w=[0.37999999999999945,0.38000000000000017,0.38000000000000017]
================== 學習 xor 函數 ====================
0:x=(-1.000,0.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
0:x=(-1.000,0.000,1.000) w=(0.990,0.000,0.010) y=0.000 yd=1.000 e=1.000
0:x=(-1.000,1.000,0.000) w=(0.980,0.010,0.010) y=0.000 yd=1.000 e=1.000
0:x=(-1.000,1.000,1.000) w=(0.980,0.010,0.010) y=0.000 yd=0.000 e=0.000
10:x=(-1.000,0.000,0.000) w=(0.800,0.100,0.100) y=0.000 yd=0.000 e=0.000
10:x=(-1.000,0.000,1.000) w=(0.790,0.100,0.110) y=0.000 yd=1.000 e=1.000
10:x=(-1.000,1.000,0.000) w=(0.780,0.110,0.110) y=0.000 yd=1.000 e=1.000
10:x=(-1.000,1.000,1.000) w=(0.780,0.110,0.110) y=0.000 yd=0.000 e=0.000
...
900:x=(-1.000,0.000,0.000) w=(0.010,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
900:x=(-1.000,0.000,1.000) w=(-0.000,-0.010,0.010) y=0.000 yd=1.000 e=1.000
900:x=(-1.000,1.000,0.000) w=(-0.010,-0.000,0.010) y=0.000 yd=1.000 e=1.000
900:x=(-1.000,1.000,1.000) w=(-0.000,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
...
990:x=(-1.000,0.000,0.000) w=(0.010,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
990:x=(-1.000,0.000,1.000) w=(-0.000,-0.010,0.010) y=0.000 yd=1.000 e=1.000
990:x=(-1.000,1.000,0.000) w=(-0.010,-0.000,0.010) y=0.000 yd=1.000 e=1.000
990:x=(-1.000,1.000,1.000) w=(-0.000,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
學習失敗 !
w=null</code></pre>
<h3 id="分析"><a href="#分析">分析</a></h3>
<p>您可以看到在上述執行結果中， AND 與 OR 兩個真值表，輸入到單層感知器進行訓練之後，都可以正確的進行學習，也就是單層感知器的輸出可以與該真值表完全一致，這代表單層感知器學習成功了。</p>
<p>但是對於 XOR 這個真值表，單層感知器卻無法讓輸出與真值表完全一致，這也正是 Minsky 所說的，單層感知器無法正確學習 XOR 函數的原因。</p>
<p>會產生這個現象的原因，可以用線性代數的概念解釋，下圖顯示了 AND, OR, XOR 等這三個真值表在二維線性空間的狀況，其中的粉紅色圓圈代表真值表的目標輸出值為 1，而淺藍色圓圈代表目標輸出為 0。</p>
<div class="figure">
<img src="../img/perceptronLinearAnalysis.jpg" alt="圖、單層感知器為何不能學習 XOR 函數的分析" /><p class="caption">圖、單層感知器為何不能學習 XOR 函數的分析</p>
</div>
<p>您可以看到對於 AND 與 OR 都可以用一條線將「粉紅色圓圈」與「淺藍色圓圈」分割開來。但是對 XOR 而言，由於粉紅色與淺藍色分別處於斜對角，我們沒有辦法畫出單一條線將兩者分開，這也是會何上述單層感知器在學習 XOR 這個函數上會失敗的原因了。</p>
<h3 id="結語-3"><a href="#結語-3">結語</a></h3>
<p>可惜的是，單層感知器並沒有辦法學會任意的布林函數，這個結果雖然令人失望，但是期望這麼簡單的模型就能擁有強大的能力，其實是一種非常天真的想法。</p>
<p>不過、如果我們將這種單層的網路繼續擴充，變成雙層以上的網路的話，其能力就會大大的提升了，這也就是我們接下來要探討的主題，反傳遞演算法 (Back-Propagation Algorithm) 了。</p>
<h3 id="參考文獻-5"><a href="#參考文獻-5">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Perceptron">Wikipedia:Perceptron</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8">維基百科：感知器</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作多層感知器與反傳遞演算法"><a href="#實作多層感知器與反傳遞演算法">實作：多層感知器與反傳遞演算法</a></h2>
<h3 id="前言-2"><a href="#前言-2">前言</a></h3>
<p>在前一篇文章中，我們討論了「單層感知器」的實作方式，然而單層感知器並沒有辦法處理像 XOR 這樣的函數。</p>
<p>為了提升「感知器」的能力，我們可以在輸入與輸出節點之間，再加入一些隱藏層，並透過這些隱藏層對整個學習空間進行更多次的分割，以便能處理 XOR 這類難以用單一線性函數分割的問題。</p>
<p>但是加入了隱藏層之後，感知器的學習與訓練就更為複雜了，這時必須有足夠的「數學理論」才能為「多層感知器」提供一個方向，而「反傳遞演算法」 (Back-Propagation) 正是這樣一個可以提供「多層感知器」學習方向的好東西，其數學基礎則是建構在多變數微分「梯度」概念之上的一種「梯度下降法」。</p>
<p>事實上、反傳遞演算法 (Back-Propagation) 的概念在 1974 年就由 Paul J. Werbos 所提出來了，但沒有受到重視，後來在 1986 年又被 Rumelhart 重新發明了出來，而且受到了廣泛的重視。</p>
<p>在本文中，我們將說明「多層感知器」與「反傳遞演算法」的概念，並用 Node.js+JavaScript 進行實作。</p>
<h3 id="模型與數學原理"><a href="#模型與數學原理">模型與數學原理</a></h3>
<p>以下是本文程式所採用的一個「多層感知器」模型，其中包含「輸入層、隱藏層與輸出層」，這種多層感知器與上一篇「單層感知器」的一個明顯不同點，在於擁有一個隱藏層，因此其能力增強了很多。</p>
<div class="figure">
<img src="../img/MLP.jpg" alt="圖、多層感知器模型 (本圖含一個隱藏層)" /><p class="caption">圖、多層感知器模型 (本圖含一個隱藏層)</p>
</div>
<p>既然反傳遞演算法是一種梯度下降法，那麼我們只要能計算出梯度的方向，就能讓「多層感知器」的權重朝著能量下降最快的方向前進。</p>
<p>但是、梯度要怎麼計算呢？先讓我們來看一張多變數的能量曲線圖。</p>
<div class="figure">
<img src="../img/Gradient.jpg" alt="圖、曲面與每一點的梯度向量" /><p class="caption">圖、曲面與每一點的梯度向量</p>
</div>
<p>在上圖中，底下的平面上所畫的向量，就是上面那個曲面在該點梯度的投影，指示了該平面最陡的下降方向。</p>
<p>在直覺概念上，曲面上某一點的梯度，其實是曲面在該點切平面的法向量，梯度的計算公式如下：</p>
<div class="figure">
<img src="../timg/4d0383fdb044.jpg" />
</div>
<p>如果我們可以計算某函數之梯度的話，只要朝著梯度的方向走去，就是最快下降的道路了。</p>
<p>採用這種沿著梯度方向往下走的方法，就稱為「梯度下降法」(Gradient Descent)，這種方法可以說是一種「貪婪演算法」(Greedy Algorithm)，因為它每次都朝著最斜的方向走去，企圖得到最大的下降幅度。</p>
<p>為了要計算梯度，我們不能採用「單層感知器裏的那種不可微分的 sign() 步階函數」 (如下圖 a 所示)，因為這樣就不能用微積分的方式計算出梯度了，而必須改用可以微分的連續函數 sigmoid() (如下圖 b 所示)，這樣才能夠透過微分計算出梯度。</p>
<div class="figure">
<img src="../img/MLP_neuron.jpg" alt="圖、兩種神經元之比較" /><p class="caption">圖、兩種神經元之比較</p>
</div>
<p>當我們改成可微分的 sigmoid() 函數之後，就可以運用微積分公式，事先求出其微分函數 dsigmoid() 。舉例而言、在本文的程式中，我們就用了雙曲正切函數 tanh(x) 作為 sigmoid() 函數，其定義如下所示：</p>
<div class="figure">
<img src="../timg/0a7a7dbd3516.jpg" />
</div>
<div class="figure">
<img src="../timg/7621e383e2fc.jpg" />
</div>
<div class="figure">
<img src="../timg/fb1e12546ddc.jpg" />
</div>
<p>由於 tanh(x) 的微分是 <img src="../timg/cd7b4072bc59.jpg" /> ，因此在下列這段程式中，我們定義了這些函數的計算方式。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tanh=<span class="kw">function</span>(x) {
  <span class="kw">return</span> (<span class="ot">Math</span>.<span class="fu">exp</span>(x) - <span class="ot">Math</span>.<span class="fu">exp</span>(-x)) / (<span class="ot">Math</span>.<span class="fu">exp</span>(x) + <span class="ot">Math</span>.<span class="fu">exp</span>(-x));
}

<span class="kw">function</span> <span class="fu">sigmoid</span>(x) {
  <span class="kw">return</span> <span class="fu">tanh</span>(x); <span class="co">// 表現較好</span>
}

<span class="kw">function</span> <span class="fu">dsigmoid</span>(x) {
  <span class="kw">return</span> <span class="fl">1.0</span> - x*x;
}</code></pre>
<p>上述程式中 dsigmoid(y) 中的 <code>1.0 - x*x</code> 則是 y=tanh(x) 的微分式，對每個 y=tanh(x) 都取微分式的時候，其實就是梯度的方向。</p>
<p>(筆者註：有些實作會採用 <img src="../timg/ae4a7a4a574d.jpg" /> 作為 sigmoid() 函數，這與 tanh(x) 函數的形狀非常類似，也是一種可行的方法)。</p>
<h3 id="程式碼-1"><a href="#程式碼-1">程式碼</a></h3>
<p>檔案：backprop.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Back-Propagation Neural Networks (JavaScript 版)</span>
<span class="co">// 由陳鍾誠修改自 Neil Schemenauer 的 Python 版</span>
<span class="co">// Python 程式網址為： http://arctrix.com/nas/python/bpnn.py</span>

<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="co">// 建立大小為 n 的陣列並填入初始值 fill</span>
<span class="kw">var</span> makeArray=<span class="kw">function</span>(n, fill) {
  <span class="kw">var</span> a = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;n; i++)
    <span class="ot">a</span>.<span class="fu">push</span>(fill);
  <span class="kw">return</span> a;
}

<span class="co">// 建立大小為 I*J 的矩陣並填入初始值 fill</span>
<span class="kw">var</span> makeMatrix=<span class="kw">function</span>(I, J, fill) {
  <span class="kw">var</span> m = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;I; i++)
    <span class="ot">m</span>.<span class="fu">push</span>(<span class="fu">makeArray</span>(J, fill));
  <span class="kw">return</span> m;
}

<span class="co">// numbersToStr():以精確度為 precision 個小數來輸出陣列 array</span>
<span class="kw">var</span> numbersToStr=<span class="kw">function</span>(array, precision) {
  <span class="kw">var</span> rzStr = <span class="st">&quot;&quot;</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">array</span>.<span class="fu">length</span>; i++) {
    <span class="kw">if</span> (array[i]&gt;=<span class="dv">0</span>)
      rzStr+=<span class="st">&quot; &quot;</span>+array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
    <span class="kw">else</span>
      rzStr+=array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  }
  <span class="kw">return</span> rzStr;
}

<span class="co">// rand():取得 a 到 b 之間的一個隨機亂數</span>
<span class="kw">var</span> rand=<span class="kw">function</span>(a, b) {
  <span class="kw">return</span> (b-a)*<span class="ot">Math</span>.<span class="fu">random</span>() + a;
}

<span class="co">// sigmoid(x)=tanh(x)</span>
<span class="kw">function</span> <span class="fu">sigmoid</span>(x) {
  <span class="kw">var</span> tanh = (<span class="ot">Math</span>.<span class="fu">exp</span>(x) - <span class="ot">Math</span>.<span class="fu">exp</span>(-x)) / (<span class="ot">Math</span>.<span class="fu">exp</span>(x) + <span class="ot">Math</span>.<span class="fu">exp</span>(-x));
  <span class="kw">return</span> tanh; <span class="co">// 雙曲正切函數</span>
}

<span class="co">// dsigmoid(x)=1-x^2;</span>
<span class="co">// 參考：http://pynopticon.googlecode.com/svn/trunk/src/vlfeat/toolbox/special/dsigmoid.m</span>
<span class="co">// 參考：http://en.wikipedia.org/wiki/Sigmoid_function</span>
<span class="kw">function</span> <span class="fu">dsigmoid</span>(x) {
  <span class="kw">return</span> <span class="fl">1.0</span> - x*x;
}

<span class="kw">function</span> <span class="fu">NeuralNet</span>() {

  <span class="co">// init()：設定網路結構與權重的隨機初始值的函數。</span>
  <span class="kw">this</span>.<span class="fu">init</span>=<span class="kw">function</span>(ni, nh, no) {
    <span class="co">// number of input, hidden, and output nodes</span>
    <span class="kw">this</span>.<span class="fu">ni</span> = ni + <span class="dv">1</span>; <span class="co">// +1 for bias node</span>
    <span class="kw">this</span>.<span class="fu">nh</span> = nh;
    <span class="kw">this</span>.<span class="fu">no</span> = no;

    <span class="co">// activations for nodes : 建立各層的節點陣列</span>
    <span class="kw">this</span>.<span class="fu">ai</span> = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">ni</span>, <span class="fl">1.0</span>);
    <span class="kw">this</span>.<span class="fu">ah</span> = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">1.0</span>);
    <span class="kw">this</span>.<span class="fu">ao</span> = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">1.0</span>);
        
    <span class="co">// create weights : 建立權重矩陣</span>
    <span class="kw">this</span>.<span class="fu">wi</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">ni</span>, <span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">0.0</span>);
    <span class="kw">this</span>.<span class="fu">wo</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">0.0</span>);
        
    <span class="co">// set them to random vaules : 隨機設定權重初始值。</span>
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span>; i++)
      <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++)
        <span class="kw">this</span>.<span class="fu">wi</span>[i][j] = <span class="fu">rand</span>(-<span class="fl">0.2</span>, <span class="fl">0.2</span>);
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++)
      <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++)
        <span class="kw">this</span>.<span class="fu">wo</span>[j][k] = <span class="fu">rand</span>(-<span class="fl">2.0</span>, <span class="fl">2.0</span>);

    <span class="co">// last change in weights for momentum  : 上一次的改變量矩陣，用來當動量以便爬過肩型區域。</span>
    <span class="kw">this</span>.<span class="fu">ci</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">ni</span>, <span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">0.0</span>);
    <span class="kw">this</span>.<span class="fu">co</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">0.0</span>);
    <span class="kw">return</span> <span class="kw">this</span>;
  }
    
  <span class="co">// update() : 計算網路的輸出的函數</span>
  <span class="kw">this</span>.<span class="fu">update</span>=<span class="kw">function</span>(inputs) {
    <span class="co">// input activations : 設定輸入值</span>
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span><span class="dv">-1</span>; i++)
      <span class="kw">this</span>.<span class="fu">ai</span>[i] = inputs[i];

    <span class="co">// hidden activations : 計算隱藏層輸出值 ah[j]</span>
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
      <span class="kw">var</span> sum = <span class="fl">0.0</span>;
      <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span>; i++)
        sum = sum + <span class="kw">this</span>.<span class="fu">ai</span>[i] * <span class="kw">this</span>.<span class="fu">wi</span>[i][j];
      <span class="kw">this</span>.<span class="fu">ah</span>[j] = <span class="fu">sigmoid</span>(sum);
    }

    <span class="co">// output activations : 計算輸出層輸出值 ao[k]</span>
    <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
      <span class="kw">var</span> sum = <span class="fl">0.0</span>;
      <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++)
        sum = sum + <span class="kw">this</span>.<span class="fu">ah</span>[j] * <span class="kw">this</span>.<span class="fu">wo</span>[j][k];
      <span class="kw">this</span>.<span class="fu">ao</span>[k] = <span class="fu">sigmoid</span>(sum);
    }

    <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">ao</span>; <span class="co">// 傳回輸出層輸出值 ao</span>
  }

  <span class="co">// backPropagate()：反傳遞學習的函數 (重要)</span>
  <span class="kw">this</span>.<span class="fu">backPropagate</span> = <span class="kw">function</span>(targets, rate, moment) {
    <span class="co">// calculate error terms for output : 計算輸出層誤差</span>
    <span class="kw">var</span> output_deltas = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">0.0</span>);
    <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
      <span class="kw">var</span> error = targets[k]-<span class="kw">this</span>.<span class="fu">ao</span>[k];
      output_deltas[k] = <span class="fu">dsigmoid</span>(<span class="kw">this</span>.<span class="fu">ao</span>[k]) * error;
    }

    <span class="co">// calculate error terms for hidden : 計算隱藏層誤差</span>
    <span class="kw">var</span> hidden_deltas = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">0.0</span>);
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
      <span class="kw">var</span> error = <span class="fl">0.0</span>;
      <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
              <span class="co">// 注意、在此輸出層誤差 output_deltas 會反傳遞到隱藏層，因此才稱為反傳遞演算法。</span>
        error = error + output_deltas[k]*<span class="kw">this</span>.<span class="fu">wo</span>[j][k]; 
          }
      hidden_deltas[j] = <span class="fu">dsigmoid</span>(<span class="kw">this</span>.<span class="fu">ah</span>[j]) * error;
    }

    <span class="co">// update output weights : 更新輸出層權重</span>
    <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
      <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
        <span class="kw">var</span> change = output_deltas[k]*<span class="kw">this</span>.<span class="fu">ah</span>[j];
        <span class="kw">this</span>.<span class="fu">wo</span>[j][k] = <span class="kw">this</span>.<span class="fu">wo</span>[j][k] + rate*change + moment*<span class="kw">this</span>.<span class="fu">co</span>[j][k];
        <span class="kw">this</span>.<span class="fu">co</span>[j][k] = change;
        <span class="co">// print N*change, M*this.co[j][k]</span>
      }
    }

    <span class="co">// update input weights : 更新輸入層權重</span>
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span>; i++) {
      <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
        <span class="kw">var</span> change = hidden_deltas[j]*<span class="kw">this</span>.<span class="fu">ai</span>[i];
        <span class="kw">this</span>.<span class="fu">wi</span>[i][j] = <span class="kw">this</span>.<span class="fu">wi</span>[i][j] + rate*change + moment*<span class="kw">this</span>.<span class="fu">ci</span>[i][j];
        <span class="kw">this</span>.<span class="fu">ci</span>[i][j] = change;
      }
    }

    <span class="co">// calculate error : 計算輸出層誤差總合</span>
    <span class="kw">var</span> error = <span class="fl">0.0</span>;
    <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="ot">targets</span>.<span class="fu">length</span>; k++)
      error = error + <span class="fl">0.5</span>*<span class="ot">Math</span>.<span class="fu">pow</span>(targets[k]-<span class="kw">this</span>.<span class="fu">ao</span>[k],<span class="dv">2</span>);
    <span class="kw">return</span> error;
  }

    <span class="co">// test() : 對真值表 (訓練樣本) 中的每個輸入都印出「網路輸出」與「期望輸出」，以便觀察學習結果是否都正確。</span>
  <span class="kw">this</span>.<span class="fu">test</span> = <span class="kw">function</span>(patterns) {
    <span class="kw">for</span> (<span class="kw">var</span> p <span class="kw">in</span> patterns) {
      <span class="kw">var</span> inputs = patterns[p][<span class="dv">0</span>];
      <span class="kw">var</span> outputs= patterns[p][<span class="dv">1</span>];
      <span class="fu">log</span>(<span class="st">&quot;%j -&gt; [%s] [%s]&quot;</span>, inputs, <span class="fu">numbersToStr</span>(<span class="kw">this</span>.<span class="fu">update</span>(inputs), <span class="dv">0</span>), <span class="fu">numbersToStr</span>(outputs, <span class="dv">0</span>));
      <span class="co">// this.dump();</span>
    }
  }

    <span class="co">// train(): 主要學習函數，反覆呼叫反傳遞算法</span>
    <span class="co">// 參數：rate: learning rate (學習速率), moment: momentum factor (動量常數)</span>
  <span class="kw">this</span>.<span class="fu">train</span>=<span class="kw">function</span>(patterns, iterations, rate, moment) {
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;iterations; i++) {
      <span class="kw">var</span> error = <span class="fl">0.0</span>;
      <span class="kw">for</span> (<span class="kw">var</span> p <span class="kw">in</span> patterns) {
        <span class="kw">var</span> pat=patterns[p];
        <span class="kw">var</span> inputs = pat[<span class="dv">0</span>];
        <span class="kw">var</span> targets = pat[<span class="dv">1</span>];
        <span class="kw">var</span> outputs = <span class="kw">this</span>.<span class="fu">update</span>(inputs);
        error = error + <span class="kw">this</span>.<span class="fu">backPropagate</span>(targets, rate, moment);
      }
      <span class="kw">if</span> (i % <span class="dv">100</span> == <span class="dv">0</span>)
        <span class="fu">log</span>(<span class="st">&#39;%d:error %j&#39;</span>, i, error);
    }
  }
}

<span class="ot">module</span>.<span class="fu">exports</span> = NeuralNet; <span class="co">// 匯出 NeuralNet 物件。</span></code></pre>
<h3 id="執行範例-1-學習-xor-函數"><a href="#執行範例-1-學習-xor-函數">執行範例 1 : 學習 XOR 函數</a></h3>
<p>檔案：backprop_xor.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> NN = <span class="fu">require</span>(<span class="st">&quot;./backprop&quot;</span>);

pat = [
  [[<span class="dv">0</span>,<span class="dv">0</span>], [<span class="dv">0</span>]],
  [[<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">1</span>]],
  [[<span class="dv">1</span>,<span class="dv">0</span>], [<span class="dv">1</span>]],
  [[<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>]]
];

<span class="co">// create a network with two input, two hidden, and one output nodes</span>
nn = <span class="kw">new</span> <span class="fu">NN</span>().<span class="fu">init</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>);
<span class="co">// train it with some patterns</span>
<span class="ot">nn</span>.<span class="fu">train</span>(pat, <span class="dv">1000</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span>);
<span class="co">// test it</span>
<span class="ot">nn</span>.<span class="fu">test</span>(pat);</code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\neural&gt;node backprop_xor
0:error 1.1411586806597014
100:error 0.15669092345306487
200:error 0.0044566959936791035
300:error 0.0018489705409186357
400:error 0.0011477205633429219
500:error 0.0008277968129286529
600:error 0.0006456614467953627
700:error 0.005231441443909679
800:error 0.0004595906757934737
900:error 0.0003945408066808508
[0,0] -&gt; [ 0 ] [ 0 ]
[0,1] -&gt; [ 1 ] [ 1 ]
[1,0] -&gt; [ 1 ] [ 1 ]
[1,1] -&gt; [-0 ] [ 0 ]</code></pre>
<h3 id="執行範例-2-學習七段顯示器函數"><a href="#執行範例-2-學習七段顯示器函數">執行範例 2 : 學習七段顯示器函數</a></h3>
<p>檔案：backprop_7seg.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/* 七段顯示器排列圖示</span>
<span class="co">  A</span>
<span class="co">F   B</span>
<span class="co">  G</span>
<span class="co">E   C</span>
<span class="co">  D</span>
<span class="co">*/</span>

<span class="kw">var</span> NN = <span class="fu">require</span>(<span class="st">&quot;./backprop&quot;</span>);

pat = [
 <span class="co">// A B C D E F G </span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]], <span class="co">// 0</span>
  [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]], <span class="co">// 1</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]], <span class="co">// 2</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>]], <span class="co">// 3</span>
  [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]], <span class="co">// 4</span>
  [[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]], <span class="co">// 5</span>
  [[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]], <span class="co">// 6</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]], <span class="co">// 7</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]], <span class="co">// 8</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]]  <span class="co">// 9</span>
];

<span class="co">// create a network with 7 input, 5 hidden, and 4 output nodes</span>
nn = <span class="kw">new</span> <span class="fu">NN</span>().<span class="fu">init</span>(<span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">4</span>);
<span class="co">// train it with some patterns</span>
<span class="ot">nn</span>.<span class="fu">train</span>(pat, <span class="dv">10000</span>, <span class="fl">0.2</span>, <span class="fl">0.01</span>);
<span class="co">// test it</span>
<span class="ot">nn</span>.<span class="fu">test</span>(pat);</code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\neural&gt;node backprop_7seg
0:error 21.80370718175807
100:error 3.0996784544877736
200:error 2.9554663137424373
300:error 2.9322332121195545
400:error 0.9175505320368402
500:error 0.5911840202045504
600:error 0.6702566860375645
700:error 0.6175745429758741
800:error 0.6073471516556047
900:error 0.601200049561361
1000:error 0.5810463514787689
1100:error 0.5364677212922591
1200:error 0.532025286869445
1300:error 0.46666848524996085
1400:error 0.48129628693742754
1500:error 0.8155362088747744
1600:error 0.5829386518767099
1700:error 0.6944742612114545
1800:error 0.49717362214697597
1900:error 0.40957109669176334
2000:error 0.5388564563993076
2100:error 0.3703582901903478
2200:error 0.5178647638260341
2300:error 0.1764373289120007
2400:error 0.25347246319196093
2500:error 0.33310966813566406
2600:error 0.17106878914718923
2700:error 0.1365002209754472
2800:error 0.1594051132697459
2900:error 0.3070991793860354
3000:error 0.3766039636947747
3100:error 0.3555367190225767
3200:error 0.11555541960454409
3300:error 0.11367500949340971
3400:error 0.12234128181753154
3500:error 0.1675446667610037
3600:error 0.09044262748000728
3700:error 0.08628776394501735
3800:error 0.27906234926518514
3900:error 0.04818459875532369
4000:error 0.062418918530088664
4100:error 0.2804289611800696
4200:error 0.13725495522690973
4300:error 0.12719742994691247
4400:error 0.07177660395615833
4500:error 0.08548411758763816
4600:error 0.03974217740792855
4700:error 0.09595126476746213
4800:error 0.03853494372617759
4900:error 0.06360901767700806
5000:error 0.07246959735102428
5100:error 0.05362418748287888
5200:error 0.04669033343340621
5300:error 0.03270696475959521
5400:error 0.03940008954106113
5500:error 0.047208537352753516
5600:error 0.049368429554604215
5700:error 0.042625347453785954
5800:error 0.056241589618292134
5900:error 0.016798400589135128
6000:error 0.03404851177897533
6100:error 0.028972975396903942
6200:error 0.01572555942490573
6300:error 0.048110746037786964
6400:error 0.039118552165591194
6500:error 0.03954060666366999
6600:error 0.047240563507126423
6700:error 0.013729342899560402
6800:error 0.03734015049471263
6900:error 0.04385222818693631
7000:error 0.038098235270263764
7100:error 0.014325393180305138
7200:error 0.039093361005808284
7300:error 0.011914229228792664
7400:error 0.012490068609142688
7500:error 0.010110888778014877
7600:error 0.017266400583083073
7700:error 0.037972260655506615
7800:error 0.010317947862704183
7900:error 0.02181165885044425
8000:error 0.033354842242808616
8100:error 0.033244707069915634
8200:error 0.02269772865101642
8300:error 0.008219315372175379
8400:error 0.03342460798252796
8500:error 0.008080093519395289
8600:error 0.02466937317542233
8700:error 0.03307092886686206
8800:error 0.033433889409569414
8900:error 0.031423007039930506
9000:error 0.018154152094468162
9100:error 0.008635680953338276
9200:error 0.030890671102892397
9300:error 0.009020762345545542
9400:error 0.015823853695083934
9500:error 0.029353956299920176
9600:error 0.03028116871034789
9700:error 0.03009059907189612
9800:error 0.025996249652393937
9900:error 0.009595759182954272
[1,1,1,1,1,1,0] -&gt; [ 0  0 -0 -0 ] [ 0  0  0  0 ]
[0,1,1,0,0,0,0] -&gt; [ 0 -0 -0  1 ] [ 0  0  0  1 ]
[1,1,0,1,1,0,1] -&gt; [-0 -0  1  0 ] [ 0  0  1  0 ]
[1,1,1,1,0,0,1] -&gt; [-0  0  1  1 ] [ 0  0  1  1 ]
[0,1,1,0,0,1,1] -&gt; [ 0  1 -0  0 ] [ 0  1  0  0 ]
[1,0,1,1,0,1,1] -&gt; [-0  1 -0  1 ] [ 0  1  0  1 ]
[1,0,1,1,1,1,1] -&gt; [-0  1  1  0 ] [ 0  1  1  0 ]
[1,1,1,0,0,0,0] -&gt; [-0  1  1  1 ] [ 0  1  1  1 ]
[1,1,1,1,1,1,1] -&gt; [ 1 -0 -0  0 ] [ 1  0  0  0 ]
[1,1,1,1,0,1,1] -&gt; [ 1  0 -0  1 ] [ 1  0  0  1 ]</code></pre>
<h3 id="結語-4"><a href="#結語-4">結語</a></h3>
<p>您可以看到上述兩個訓練案例，都是完全正確的，這代表反傳遞演算法可以讓多層感知器學會 XOR 與七段顯示器的函數。</p>
<p>當然、多層感知器也可以學會更難的問題，像是手寫的數字與英文字辨認等等，手寫中文辨認和語音辨認當然也是可行的，只不過需要很多的訓練範例與節點，學習的效果才會夠好就是了！</p>
<h3 id="參考文獻-6"><a href="#參考文獻-6">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Backpropagation">Wikipedia:Backpropagation</a></li>
<li><a href="http://en.wikipedia.org/wiki/Multilayer_perceptron">Wikipedia:Multilayer perceptron</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95">維基百科:反向傳播演算法</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA">維基百科:多層感知機</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="圖形搜尋簡介"><a href="#圖形搜尋簡介">圖形搜尋簡介</a></h2>
<h3 id="簡介-2"><a href="#簡介-2">簡介</a></h3>
<p>在離散數學、演算法與人工智慧的領域，很多問題可以表示為「節點與連線所形成的圖形」，一個程式要解決某問題其實是在這個圖形裏把目標節點給找出來，於是問題求解就簡化成了圖形的搜尋，我們只要把解答給「找出來」就行了。</p>
<p>圖形搜尋的方法大致可以分為「深度優先搜尋 (Depth-First Search, DFS)、廣度優先搜尋 (Breath-First Search, BFS)、最佳優先搜尋 (Best-First Search, BestFS) 等三類。</p>
<p>然後針對最佳優先搜尋的部份，還有一種具有理論背景，且較為強大好用的 A* 搜尋法可採用。</p>
<h3 id="圖形的表達"><a href="#圖形的表達">圖形的表達</a></h3>
<p>圖形是由節點 (node) 與連線 (edge) 所組成的。舉例而言，以下是一個包含六個節點與十條連線的簡單圖形。</p>
<div class="figure">
<img src="../img/graphSearch.jpg" alt="圖、圖形 Graph 的範例" /><p class="caption">圖、圖形 Graph 的範例</p>
</div>
<h3 id="深度優先搜尋"><a href="#深度優先搜尋">深度優先搜尋</a></h3>
<p>所謂的「深度優先搜尋」 (Depth-First Search, DFS)，就是一直往尚未訪問過的第一個鄰居節點走去的一種方法，這種方法可以採用程式設計中的「遞迴技巧」完成，以下是深度搜尋的演算法：</p>
<pre><code>Algorithm DFS(graph, node) {  // 深度優先搜尋，graph : 圖形, node:節點
  if (node.visited) return;     // 如果已訪問過，就不再訪問
  node.visited = 1;             //   並設定為已訪問
  foreach (neighbor of node)  // 對於每個鄰居
    DFS(graph, neighbor);     //   逐一進行深度優先搜尋的訪問。
end</code></pre>
<p>您可以看到上述的演算法中，我們單純採用遞迴的方式，就可以輕易的完成整個 DFS 演算法。</p>
<p>當然、實作為程式的時候，會稍微複雜一點，以下是使用 Javascript 的實作方式：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">dfs</span>(g, node) { <span class="co">// 深度優先搜尋</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> !=<span class="dv">0</span>) <span class="kw">return</span>;   <span class="co">// 如果已訪問過，就不再訪問</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);       <span class="co">// 否則、印出節點</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;              <span class="co">//   並設定為已訪問</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>;  <span class="co">// 取出鄰居節點</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) {  <span class="co">// 對於每個鄰居</span>
    <span class="fu">dfs</span>(g, neighbors[i]);     <span class="co">//   逐一進行訪問</span>
  }
}</code></pre>
<p>針對上述的範例圖形，若採用深度優先搜尋，其結果可能如下所示 (圖中紅色的數字代表訪問順序)</p>
<div class="figure">
<img src="../img/dfs.jpg" alt="圖、深度優先搜尋的順序" /><p class="caption">圖、深度優先搜尋的順序</p>
</div>
<h3 id="廣度優先搜尋"><a href="#廣度優先搜尋">廣度優先搜尋</a></h3>
<p>雖然深度優先搜尋可以搜尋整個圖形，但是卻很可能繞了很久才找到目標，於是從起點到目標可能會花費很久的時間 (或說路徑長度過長)。</p>
<p>如果我們想找出到達目標最少的步驟，那麼就可以採用「廣度優先搜尋」 (Breath-First Search, BFS) 的方式。</p>
<p>廣度優先搜尋 BFS 是從一個節點開始，將每個鄰居節點都一層一層的拜訪下去，深度最淺的節點會優先被拜訪的方式。</p>
<p>舉例而言，針對上述的圖形範例，若採用「廣度優先搜尋 BFS 」的方式，那麼拜訪順序將會如下所示：</p>
<div class="figure">
<img src="../img/bfs.jpg" alt="圖、廣度優先搜尋的順序" /><p class="caption">圖、廣度優先搜尋的順序</p>
</div>
<p>要能用程式進行廣度優先搜尋，必須採用「先進先出」(First-in First-Out, FIFO) 的方式管理節點，因此通常在「廣度優先搜尋」裏會有個佇列 (queue) 結構，以下是 BFS 的演算法：</p>
<pre><code>Algorithm BFS(graph, queue)
  if queue.empty() return;
    node = queue.dequeue();
    if (!node.visited)
      node.visited = true
    else
      return;
    foreach (neighbor of node)
      if (!neighbor.visited)
          queue.push(neighbor)
end</code></pre>
<p>以下是使用 Javascript 的 BFS 程式實作片段：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">bfs</span>(g, q) { <span class="co">// 廣度優先搜尋</span>
  <span class="kw">if</span> (<span class="ot">q</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// 如果 queue 已空，則返回。</span>
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否則、取出 queue 的第一個節點。</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> == <span class="dv">0</span>)        <span class="co">// 如果該節點尚未拜訪過。</span>
    g[node].<span class="fu">v</span> = <span class="dv">1</span>;           <span class="co">//   標示為已拜訪</span>
  <span class="kw">else</span>                       <span class="co">// 否則 (已訪問過)</span>
    <span class="kw">return</span>;                  <span class="co">//   不繼續搜尋，直接返回。</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);      <span class="co">// 印出節點</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>; <span class="co">// 取出鄰居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 對於每個鄰居</span>
    <span class="kw">var</span> n = neighbors[i];
    <span class="kw">if</span> (!g[n].<span class="fu">visited</span>)       <span class="co">// 假如該鄰居還沒被拜訪過</span>
      <span class="ot">q</span>.<span class="fu">push</span>(n);             <span class="co">//   就放入 queue 中</span>
  }
  <span class="fu">bfs</span>(g, q);
}</code></pre>
<h3 id="最佳優先搜尋"><a href="#最佳優先搜尋">最佳優先搜尋</a></h3>
<p>但是、上述兩個方法其實都還不夠好，深度搜尋會猛衝亂衝，而廣度搜尋則會耗費太多的記憶體，並且沒有效率，無法很快的找到目標點。</p>
<p>假如我們能夠知道哪些點距離目標點最近，也就是哪些點比較好的話，那就能採用「最佳優先搜尋 (Best-First Search) 的方式來搜尋了。</p>
<p>最佳優先搜尋的實作方法與廣度優先搜尋類似，但是並不採用佇列 (queue) ，而是採用一種根據優先程度排序的結構，每次都取出最好的那個繼續進行搜尋。</p>
<p>但是、節點的好壞通常很難評估，單純採用某種距離去評估往往會過度簡化問題，這點往往是最佳優先搜尋的困難之所在。</p>
<p>還好、有時我們不需要非常精確的評估，只要問題符合 <img src="../timg/9c5e6fefcb1f.jpg" /> 這樣的單調 (monotone) 特性，就可以使用 <code>A*</code> 演算法來進行較快速的搜尋，這種方法比廣度優先搜尋通常快很多，因為 <code>A*</code> 不會搜尋所有節點，而是有系統的朝著整體較好的方向前進，這種方法在電腦遊戲 (Game) 上常被用在 NPC (非人類角色) 的智慧型搜尋行為設計上面，是人工智慧搜尋方法中較強大的一種。</p>
<h3 id="參考文獻-7"><a href="#參考文獻-7">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia:A* search algorithm</a></li>
<li><a href="http://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%AF%BB%E7%AE%97%E6%B3%95">維基百科:A*搜尋演算法</a></li>
<li><a href="http://zh.wikipedia.org/zh-tw/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">維基百科:廣度優先搜索</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">維基百科:深度優先搜索</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作深度與廣度搜尋法"><a href="#實作深度與廣度搜尋法">實作：深度與廣度搜尋法</a></h2>
<h3 id="簡介-3"><a href="#簡介-3">簡介</a></h3>
<p>為了進一步理解深度優先搜尋 (Depth-First Search) 與廣度優先搜尋 (Breath-First Search) ，我們將在本文中採用 JavaScript 實作這兩個圖形搜尋算法，並且在 node.js 平台上進行測試。</p>
<p>在以下程式中，變數 g 代表下列圖形，而程式中的 dfs() 函數代表深度優先搜尋算法，bfs() 函數代表廣度優先搜尋算法。</p>
<div class="figure">
<img src="../img/graphSearch.jpg" alt="圖、圖形 Graph 的範例" /><p class="caption">圖、圖形 Graph 的範例</p>
</div>
<h3 id="程式實作"><a href="#程式實作">程式實作</a></h3>
<p>檔案：graphSearch.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);

<span class="kw">var</span> printf = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">process</span>.<span class="ot">stdout</span>.<span class="fu">write</span>(<span class="ot">util</span>.<span class="ot">format</span>.<span class="fu">apply</span>(<span class="kw">null</span>, arguments)); 
}

<span class="kw">function</span> <span class="fu">enqueue</span>(a, o) { <span class="ot">a</span>.<span class="fu">push</span>(o); }
<span class="kw">function</span> <span class="fu">dequeue</span>(a) { <span class="kw">return</span> <span class="ot">a</span>.<span class="fu">shift</span>(); }

<span class="kw">var</span> g = {            <span class="co">// graph: 被搜尋的網路</span>
  <span class="dv">1</span>: {<span class="dt">n</span>:[<span class="dv">2</span>,<span class="dv">5</span>], <span class="dt">v</span>:<span class="dv">0</span>}, <span class="co">// n: neighbor (鄰居), v: visited (是否被訪問過)</span>
  <span class="dv">2</span>: {<span class="dt">n</span>:[<span class="dv">3</span>,<span class="dv">4</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">3</span>: {<span class="dt">n</span>:[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">4</span>: {<span class="dt">n</span>:[<span class="dv">5</span>,<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">5</span>: {<span class="dt">n</span>:[<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">6</span>: {<span class="dt">n</span>:[], <span class="dt">v</span>:<span class="dv">0</span>}
};

<span class="kw">function</span> <span class="fu">init</span>(g) { <span class="co">// 初始化、設定 visited 為 0</span>
  <span class="kw">for</span> (i <span class="kw">in</span> g) g[i].<span class="fu">v</span> = <span class="dv">0</span>;
}

<span class="kw">function</span> <span class="fu">dfs</span>(g, node) { <span class="co">// 深度優先搜尋</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> !=<span class="dv">0</span>) <span class="kw">return</span>;   <span class="co">// 如果已訪問過，就不再訪問</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);       <span class="co">// 否則、印出節點</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;              <span class="co">//   並設定為已訪問</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>;  <span class="co">// 取出鄰居節點</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) {  <span class="co">// 對於每個鄰居</span>
    <span class="fu">dfs</span>(g, neighbors[i]);     <span class="co">//   逐一進行訪問</span>
  }
}

<span class="kw">var</span> queue=[<span class="dv">1</span>];            <span class="co">// BFS 用的 queue, 起始點為 1。</span>

<span class="kw">function</span> <span class="fu">bfs</span>(g, q) { <span class="co">// 廣度優先搜尋</span>
  <span class="kw">if</span> (<span class="ot">q</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// 如果 queue 已空，則返回。</span>
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否則、取出 queue 的第一個節點。</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> == <span class="dv">0</span>)        <span class="co">// 如果該節點尚未拜訪過。</span>
    g[node].<span class="fu">v</span> = <span class="dv">1</span>;           <span class="co">//   標示為已拜訪</span>
  <span class="kw">else</span>                       <span class="co">// 否則 (已訪問過)</span>
    <span class="kw">return</span>;                  <span class="co">//   不繼續搜尋，直接返回。</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);      <span class="co">// 印出節點</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>; <span class="co">// 取出鄰居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 對於每個鄰居</span>
    <span class="kw">var</span> n = neighbors[i];
    <span class="kw">if</span> (!g[n].<span class="fu">visited</span>)       <span class="co">// 假如該鄰居還沒被拜訪過</span>
      <span class="ot">q</span>.<span class="fu">push</span>(n);             <span class="co">//   就放入 queue 中</span>
  }
  <span class="fu">bfs</span>(g, q);
}

<span class="fu">printf</span>(<span class="st">&quot;dfs:&quot;</span>); <span class="fu">init</span>(g); <span class="fu">dfs</span>(g, <span class="dv">1</span>); <span class="fu">printf</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);     <span class="co">// 呼叫深度優先搜尋。</span>
<span class="fu">printf</span>(<span class="st">&quot;bfs:&quot;</span>); <span class="fu">init</span>(g); <span class="fu">bfs</span>(g, queue); <span class="fu">printf</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="co">// 呼叫廣度優先搜尋。</span></code></pre>
<h3 id="執行結果-1"><a href="#執行結果-1">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node graphSearch.js
dfs:1=&gt;2=&gt;3=&gt;4=&gt;5=&gt;6=&gt;
bfs:1=&gt;2=&gt;5=&gt;3=&gt;4=&gt;6=&gt;</code></pre>
<h3 id="結語-5"><a href="#結語-5">結語</a></h3>
<p>從以上範例您可以看到 BFS 與 DFS 之差異，不過我們沒有為節點加入好壞的評估函數，因此沒有實作最佳優先搜尋，或許讀者可以自行嘗試修改看看。</p>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作以深度優先搜尋解決老鼠走迷宮問題"><a href="#實作以深度優先搜尋解決老鼠走迷宮問題">實作：以深度優先搜尋解決老鼠走迷宮問題</a></h2>
<h3 id="前言-3"><a href="#前言-3">前言</a></h3>
<p>雖然深度優先搜尋 (DFS) 與廣度優先搜尋 (BFS) 等演算法通常是用在「圖形」這種結構上的，不過「圖形」的結構倒是不一定要真實且完整的表達出來，在很多人工智慧的問題上，我們不會看到完整的「圖形結構」，只會看到某個節點有哪些鄰居節點，然後就可以用 BFS 與 DFS 進行搜尋了。</p>
<p>老鼠走迷宮問題，就是一個可以採用圖形搜尋來解決的經典問題，其中每個節點的鄰居，就是上下左右四個方向，只要沒有被牆給擋住，就可以走到鄰居節點去，因此我們可以採用圖形搜尋的方法來解決迷宮問題，以下是我們的程式實作。</p>
<h3 id="程式實作老鼠走迷宮"><a href="#程式實作老鼠走迷宮">程式實作：老鼠走迷宮</a></h3>
<p>檔案：pathFinder.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="kw">function</span> <span class="fu">matrixPrint</span>(m) {
  <span class="kw">for</span>(<span class="kw">var</span> i=<span class="dv">0</span>;i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++)
    <span class="fu">log</span>(m[i]);
}

<span class="kw">function</span> <span class="fu">strset</span>(s, i, c) {
  <span class="kw">return</span> <span class="ot">s</span>.<span class="fu">substr</span>(<span class="dv">0</span>, i) + c + <span class="ot">s</span>.<span class="fu">substr</span>(i<span class="dv">+1</span>);
}

<span class="kw">function</span> <span class="fu">findPath</span>(m, x, y) {
  <span class="fu">log</span>(<span class="st">&quot;=========================&quot;</span>);
  <span class="fu">log</span>(<span class="st">&quot;x=&quot;</span>+x+<span class="st">&quot; y=&quot;</span>+y);
  <span class="fu">matrixPrint</span>(m);
  <span class="kw">if</span> (x&gt;=<span class="dv">6</span>||y&gt;=<span class="dv">8</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;*&#39;</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;+&#39;</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39; &#39;</span>) m[x] = <span class="fu">strset</span>(m[x], y, <span class="st">&#39;.&#39;</span>);
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;.&#39;</span> &amp;&amp; (x == <span class="dv">5</span> || y==<span class="dv">7</span>)) 
    <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span> (y&lt;<span class="dv">7</span>&amp;&amp;m[x][y<span class="dv">+1</span>]==<span class="st">&#39; &#39;</span>) <span class="co">//向右</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x,y<span class="dv">+1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(x&lt;<span class="dv">5</span>&amp;&amp;m[x<span class="dv">+1</span>][y]==<span class="st">&#39; &#39;</span>) <span class="co">//向下</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x<span class="dv">+1</span>,y)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(y&gt;<span class="dv">0</span>&amp;&amp;m[x][y<span class="dv">-1</span>]==<span class="st">&#39; &#39;</span>) <span class="co">//向左</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x,y<span class="dv">-1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(x&gt;<span class="dv">0</span>&amp;&amp;m[x<span class="dv">-1</span>][y]==<span class="st">&#39; &#39;</span>) <span class="co">//向上</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x<span class="dv">-1</span>,y)) <span class="kw">return</span> <span class="kw">true</span>;
  m[x][y]=<span class="st">&#39;+&#39;</span>;
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="kw">var</span> m =[<span class="st">&quot;********&quot;</span>, 
        <span class="st">&quot;** * ***&quot;</span>,
        <span class="st">&quot;     ***&quot;</span>,
        <span class="st">&quot;* ******&quot;</span>,
        <span class="st">&quot;*     **&quot;</span>,
        <span class="st">&quot;***** **&quot;</span>];
    
<span class="fu">findPath</span>(m, <span class="dv">2</span>, <span class="dv">0</span>);
<span class="fu">log</span>(<span class="st">&quot;=========================&quot;</span>);
<span class="fu">matrixPrint</span>(m);</code></pre>
<h3 id="執行結果-2"><a href="#執行結果-2">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node pathFinder.js
=========================
x=2 y=0
********
** * ***
     ***
* ******
*     **
***** **
=========================
x=2 y=1
********
** * ***
.    ***
* ******
*     **
***** **
=========================
x=2 y=2
********
** * ***
..   ***
* ******
*     **
***** **
=========================
x=2 y=3
********
** * ***
...  ***
* ******
*     **
***** **
=========================
x=2 y=4
********
** * ***
.... ***
* ******
*     **
***** **
=========================
x=1 y=4
********
** * ***
.....***
* ******
*     **
***** **
=========================
x=1 y=2
********
** *.***
.....***
* ******
*     **
***** **
=========================
x=3 y=1
********
**.*.***
.....***
* ******
*     **
***** **
=========================
x=4 y=1
********
**.*.***
.....***
*.******
*     **
***** **
=========================
x=4 y=2
********
**.*.***
.....***
*.******
*.    **
***** **
=========================
x=4 y=3
********
**.*.***
.....***
*.******
*..   **
***** **
=========================
x=4 y=4
********
**.*.***
.....***
*.******
*...  **
***** **
=========================
x=4 y=5
********
**.*.***
.....***
*.******
*.... **
***** **
=========================
x=5 y=5
********
**.*.***
.....***
*.******
*.....**
***** **
=========================
********
**.*.***
.....***
*.******
*.....**
*****.**</code></pre>
<h3 id="結語-6"><a href="#結語-6">結語</a></h3>
<p>在上面的輸出結果中，<code>*</code> 代表該位置是牆壁，而空格則代表是可以走的路，老鼠走過的地方會放下一個 <code>.</code> 符號，於是您可以看到在上述程式的輸出中，老鼠最後走出了迷宮，完成了任務。</p>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作以廣度優先搜尋解決拼圖問題"><a href="#實作以廣度優先搜尋解決拼圖問題">實作：以廣度優先搜尋解決拼圖問題</a></h2>
<h3 id="前言-4"><a href="#前言-4">前言</a></h3>
<p>以下的「拼圖問題」是將一個已經移動打亂過的拼盤，想辦法移動回原本樣子的問題。</p>
<div class="figure">
<img src="../img/puzzle.jpg" alt="圖、本文程式中的拼圖問題" /><p class="caption">圖、本文程式中的拼圖問題</p>
</div>
<p>在以下程式中，我們用一個 3*3 的陣列來代表拼盤，並且用數字 0 來代表其中的空格，因此將方塊 2 移動到空格，其實是用將 0 與 2 兩個數字位置交換所達成的。</p>
<p>透過這樣的資料結構，我們就可以用「廣度優先搜尋」(BFS) 來解決拼圖問題了，以下是我們用 JavaScript 實作，並用 node.js 進行測試的結果。</p>
<h3 id="程式實作拼圖問題"><a href="#程式實作拼圖問題">程式實作：拼圖問題</a></h3>
<p>檔案：puzzleSearch.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;
<span class="kw">var</span> up = <span class="dv">1</span>, right=<span class="dv">2</span>, down=<span class="dv">3</span>, left=<span class="dv">4</span>;

<span class="kw">function</span> <span class="fu">enqueue</span>(a, o) { <span class="ot">a</span>.<span class="fu">push</span>(o); }
<span class="kw">function</span> <span class="fu">dequeue</span>(a) { <span class="kw">return</span> <span class="ot">a</span>.<span class="fu">shift</span>(); }
<span class="kw">function</span> <span class="fu">equal</span>(a, b) { <span class="kw">return</span> <span class="ot">JSON</span>.<span class="fu">stringify</span>(a)===<span class="ot">JSON</span>.<span class="fu">stringify</span>(b); }
<span class="kw">function</span> <span class="fu">board2str</span>(b) { <span class="kw">return</span> <span class="ot">b</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); }

<span class="kw">function</span> <span class="fu">findXY</span>(board, value) {
  <span class="kw">for</span> (<span class="kw">var</span> x=<span class="dv">0</span>; x&lt;<span class="ot">board</span>.<span class="fu">length</span>; x++)
    <span class="kw">for</span> (<span class="kw">var</span> y=<span class="dv">0</span>; y&lt;board[x].<span class="fu">length</span>; y++)
      <span class="kw">if</span> (board[x][y] === value)
        <span class="kw">return</span> {<span class="dt">x</span>:x,<span class="dt">y</span>:y};
  <span class="kw">return</span> <span class="kw">null</span>;
}

<span class="kw">function</span> <span class="fu">boardClone</span>(b) {
  <span class="kw">var</span> nb = [];
  <span class="kw">for</span> (<span class="kw">var</span> x <span class="kw">in</span> b)
    nb[x] = b[x].<span class="fu">slice</span>(<span class="dv">0</span>);
  <span class="kw">return</span> nb;
}

<span class="kw">function</span> <span class="fu">swap</span>(b,x1,y1,x2,y2) {
  x2 = <span class="ot">Math</span>.<span class="fu">round</span>(x2), y2=<span class="ot">Math</span>.<span class="fu">round</span>(y2);
  <span class="kw">if</span> (x2&lt;<span class="dv">0</span> || x2 &gt; <span class="dv">2</span> || y2&lt;<span class="dv">0</span> || y2&gt;<span class="dv">2</span>) 
    <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">var</span> t = b[x1][y1];
  b[x1][y1]=b[x2][y2];
  b[x2][y2]=t;
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="kw">function</span> <span class="fu">move</span>(board, dir) {
  <span class="kw">var</span> xy = <span class="fu">findXY</span>(board, <span class="dv">0</span>);
  <span class="kw">var</span> x = <span class="ot">xy</span>.<span class="fu">x</span>, y=<span class="ot">xy</span>.<span class="fu">y</span>;
  <span class="kw">var</span> nboard = <span class="fu">boardClone</span>(board);
  <span class="kw">var</span> s = <span class="kw">false</span>;
  <span class="kw">switch</span> (dir) {
    <span class="kw">case</span> <span class="dt">up</span>:    s=<span class="fu">swap</span>(nboard,x,y,x<span class="dv">-1</span>,y); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dt">right</span>: s=<span class="fu">swap</span>(nboard,x,y,x,y<span class="dv">+1</span>); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dt">down</span>:  s=<span class="fu">swap</span>(nboard,x,y,x<span class="dv">+1</span>,y); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dt">left</span>:  s=<span class="fu">swap</span>(nboard,x,y,x,y<span class="dv">-1</span>); <span class="kw">break</span>;
  }
  <span class="kw">if</span> (s)
    <span class="kw">return</span> nboard;
  <span class="kw">else</span>
    <span class="kw">return</span> <span class="kw">null</span>;
}

<span class="kw">function</span> <span class="fu">moveAdd</span>(board, dir, neighbors) {
  <span class="kw">var</span> nboard = <span class="fu">move</span>(board, dir);
  <span class="kw">if</span> (nboard !== <span class="kw">null</span>) {
    <span class="ot">neighbors</span>.<span class="fu">push</span>(nboard);
  }
}

<span class="kw">function</span> <span class="fu">getNeighbors</span>(board) {
  <span class="kw">var</span> neighbors = [];
  <span class="fu">moveAdd</span>(board, up,    neighbors);
  <span class="fu">moveAdd</span>(board, down,  neighbors);
  <span class="fu">moveAdd</span>(board, right, neighbors);
  <span class="fu">moveAdd</span>(board, left,  neighbors);
  <span class="kw">return</span> neighbors;
}

<span class="kw">var</span> goal = [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], 
            [<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">4</span>],
            [<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>]];

<span class="kw">var</span> start= [[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>], 
            [<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">5</span>],
            [<span class="dv">7</span>,<span class="dv">0</span>,<span class="dv">6</span>]];

<span class="kw">var</span> queue=[start];            <span class="co">// BFS 用的 queue, 起始點為 1。</span>
<span class="kw">var</span> visited={};
<span class="kw">var</span> parent={};
<span class="kw">var</span> level={};

<span class="kw">function</span> <span class="fu">bfs</span>(q, goal) { <span class="co">// 廣度優先搜尋</span>
  <span class="kw">while</span> (<span class="ot">q</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
    <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否則、取出 queue 的第一個節點。</span>
    <span class="kw">var</span> nodestr = <span class="fu">board2str</span>(node);
<span class="co">//  log(&quot;q.length=%d level=%d\n===node===\n%s==parent==\n%s&quot;, q.length, level[nodestr], nodestr, parent[nodestr]); // 印出節點</span>
    <span class="kw">if</span> (<span class="fu">equal</span>(node, goal)) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span> (visited[nodestr]===<span class="kw">undefined</span>)        <span class="co">// 如果該節點尚未拜訪過。</span>
      visited[nodestr] = <span class="kw">true</span>; <span class="co">//   標示為已拜訪</span>
    <span class="kw">else</span>                       <span class="co">// 否則 (已訪問過)</span>
      <span class="kw">continue</span>;                <span class="co">//   不繼續搜尋，直接返回。</span>
    <span class="kw">var</span> neighbors = <span class="fu">getNeighbors</span>(node); <span class="co">// 取出鄰居。</span>
    <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 對於每個鄰居</span>
      <span class="kw">var</span> n = neighbors[i];
      <span class="kw">var</span> nstr = <span class="fu">board2str</span>(n);
      <span class="kw">if</span> (!visited[nstr]) {    <span class="co">// 假如該鄰居還沒被拜訪過</span>
        parent[nstr] = nodestr;
    level[nstr] = level[nodestr] + <span class="dv">1</span>;
        <span class="fu">enqueue</span>(q, n);         <span class="co">//   就放入 queue 中</span>
      }
    }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="kw">function</span> <span class="fu">backtrace</span>(goal) {
  <span class="fu">log</span>(<span class="st">&quot;======= backtrace =========&quot;</span>);
  <span class="kw">var</span> nodestr = <span class="fu">board2str</span>(goal);
  <span class="kw">while</span> (nodestr !== <span class="kw">undefined</span>) {
    <span class="fu">log</span>(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, nodestr);
    nodestr = parent[nodestr];
  }
}

level[<span class="fu">board2str</span>(start)]=<span class="dv">0</span>;
<span class="kw">var</span> found = <span class="fu">bfs</span>(queue, goal); <span class="co">// 呼叫廣度優先搜尋。</span>
<span class="fu">log</span>(<span class="st">&quot;bfs:found=%s&quot;</span>, found);
<span class="kw">if</span> (found)
  <span class="fu">backtrace</span>(goal);</code></pre>
<h3 id="執行結果-3"><a href="#執行結果-3">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node puzzleSearch.js
bfs:found=true
======= backtrace =========
1,2,3
8,0,4
7,6,5

1,0,3
8,2,4
7,6,5

1,3,0
8,2,4
7,6,5

1,3,4
8,2,0
7,6,5

1,3,4
8,2,5
7,6,0

1,3,4
8,2,5
7,0,6</code></pre>
<h3 id="結語-7"><a href="#結語-7">結語</a></h3>
<p>在上述執行結果中，我們是將盤面拼完後，才逆向追蹤印出移動過程，因此整個移動方法應該從最下面的盤面看起。換句話說，真正的順序如下：</p>
<pre><code>1,3,4    1,3,4    1,3,4     1,3,0    1,0,3    1,2,3
8,2,5 =&gt; 8,2,5 =&gt; 8,2,0 =&gt;  8,2,4 =&gt; 8,2,4 =&gt; 8,0,4
7,0,6    7,6,0    7,6,5     7,6,5    7,6,5    7,6,5</code></pre>
<p>從上面過程中，您可以看出我們的程式將打亂的盤面給拼回來了。</p>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h1 id="電腦下棋"><a href="#電腦下棋">電腦下棋</a></h1>
<p>自從有了電腦之後，人們就一直想讓電腦「學會」下棋的能力。事實上、遠在 1952 年，那時的電腦雖然還不具備下棋的能力，但是資訊領域的理論派大師圖靈 (Alan Turing) 就已經在構思如何寫「電腦下棋」的程式了，以下是節錄自維基百科的一段描述：</p>
<blockquote>
<p>1952年，圖靈寫了一個西洋棋程式。可是，當時沒有一台電腦有足夠的運算能力去執行這個程式，他就模仿電腦，每走一步要用半小時。他與一位同事下了一盤，結果程式輸了。</p>
<p>後來美國新墨西哥州洛斯阿拉莫斯國家實驗室的研究群根據圖靈的理論，在ENIAC上設計出世界上第一個電腦程式的象棋－洛斯阿拉莫斯象棋。</p>
</blockquote>
<p>世界上有很多種棋類遊戲，對於台灣人而言，最常下的幾種棋類，大至上包含「圍棋、象棋、五子棋、西洋棋」等等。</p>
<p>圍棋的英文名稱為 GO，起源於中國，推測起源時間為大約公元前6世紀。傳說堯的兒子丹朱頑劣，堯發明圍棋以教育丹朱，陶冶其性情。目前圍棋的最早可靠記載見於春秋時期的《左傳》，戰國時期的弈秋是見於史籍的第一位棋手，最早的圍棋文物可以追溯到戰國時期。漢朝時棋盤為17路，南北朝時候，棋盤定型為現在的19道棋盤，傳入朝鮮半島，並且出現了評定棋手水平的圍棋九品制。圍棋逐漸成為中國古代知識階層修身養性的一項必修課目，為「琴棋書畫」四藝之一。</p>
<p>圍棋在公元7世紀傳入日本，很快就流行於宮廷和貴族之中。戰國末期，豐臣秀吉設立棋所。德川幕府時代，出現了在天皇或將軍面前對弈的「御城棋」，日本圍棋逐漸興盛，出現了本因坊、安井、井上、林等圍棋世家。其中坊門尤其人才輩出，先後出現了道策、丈和、秀和、秀策、秀甫、秀榮等傑出棋士。日本圍棋由於廢除了中國古代圍棋的座子制（古代中國圍棋是放四個座子，就是兩黑兩白放在對角星的位置上，雙方在這個基礎上開始布局），布局理論得以極大發展。</p>
<p>明治維新以後，棋手失去幕府支援，開始謀求新的謀生手段，導致了新聞棋戰和現代段位制的出現，並創立了全國性的日本棋院。昭和時代，吳清源和木谷實共同掀起了「新布局」的潮流，開始了現代圍棋的時代。其後日本棋界一流棋手輩出，如坂田榮男，藤澤秀行，高川格，及後來的大竹英雄，武宮正樹，小林光一，石田芳夫等。</p>
<div class="figure">
<img src="../img/ChineseChess.jpg" />
</div>
<p>五子棋的英文名稱為 GOMOKU，在日本平安時代就有，是日本人頗受歡迎的棋類。自1899年日本棋士黒岩涙香證明了原始規則的五子棋先下必勝後，五子棋邁入一條不斷改良的道路，經過數十年的修改、驗證、再修改，最終發展出加入禁手的五子棋，並經過公開徵名，稱為連珠（RENJU），因此規則在日本成型，又稱為日式規則或連珠規則。</p>
<p>西洋棋的英文就是 chess，又稱歐洲象棋或國際象棋，一般被認爲源自一種印度的遊戲——恰圖蘭卡，7世紀時流傳至波斯成為波斯象棋。穆斯林統治波斯後，它被帶到伊斯蘭的國家。九世紀傳入南歐，10世紀時傳到西班牙，11世紀傳到英國。15世紀末，現代西洋棋的規則逐漸成形。現代的玩法與19世紀時的大致相同。由於流傳已久，因此在各地與各時期產生不少的西洋棋變體規則。</p>
<div class="figure">
<img src="../img/EuropeanChess.jpg" />
</div>
<p>相信大部分的人對以上棋類都相當熟悉，也都知曉這些棋類的遊戲規則了，現在、就讓我們大致介紹一下如何撰寫「電腦下棋」的程式好了。</p>
<p>要寫下棋程式，大致有三個關鍵技巧，第一個是盤面的表達，第二個是評估函數，第三個是搜尋技巧。</p>
<ul>
<li>盤面表達：通常我們可以用一個陣列代表盤面。舉例而言、在支援 Unicode 的系統中，我們可以用字元陣列代表棋盤，對於圍棋或五子棋而言，我們可以用 O 代表白子、 X 代表黑子，然後用空白字元代表該位置還沒有任何子。同樣的、我們可以用中文字的「將士象車馬砲卒」與「帥仕相俥傌炮兵」來代表象棋的子，對於西洋棋也可以如法炮製，只要對每個棋子都取一個中文名字或代號就行了。</li>
<li>評估函數：接著我們可以寫一個函數來評估某個盤面的分數，舉例而言、對於五子棋而言，我方連五子得 100 分，對方連五子則扣 100 分，我方連四子得 30 分，對方連四子則扣 30 分， ......，我方連兩子得 2 分，對方連兩子則扣兩分。而對象棋而言，則可以對每一子的重要性計分，例如將算 100 分，車算 50 分，砲算 30 分等等。</li>
<li>搜尋策略：對於比較複雜的棋類，我們通常需要事先設想後面好幾步的情況，能夠想得越周全且越遠的人，通常就會越厲害。電腦下棋也是如此，由於現在電腦的速度非常快，因此往往可以利用 Min-Max 演算法搜尋兩三層，甚至到五六層。而且、只要加上 Alpha-Beta Cut 修剪法，有時甚至可以搜尋到十幾層，這樣的能力往往可以超過人類，因此現在電腦在「象棋、西洋棋、五子棋」上的棋力通常很強，即使職業的棋手也未必能夠打贏電腦。(不過圍棋目前還是人類較強，電腦還沒辦法下贏職業棋手)。</li>
</ul>
<p>在 1997 年的時候，IBM 曾經用他的「深藍」(Deep Blue) 電腦與當時的世界西洋棋王「卡斯巴羅夫」公開對戰，結果「卡斯巴羅夫」在第一盤勝利之後，卻連續輸了兩盤，於是敗給了「深藍電腦」。雖然這場棋賽引起了一些爭議，但是電腦在西洋棋上的棋力，應該已經確定不亞於職業棋手，甚至是有過之而無不及了。</p>
<p>我們將在以下的幾篇文章中，進一步討論電腦下棋的方法，並且實作出一個「五子棋」的「電腦自動下棋」程式。</p>
<h3 id="參考文獻-8"><a href="#參考文獻-8">參考文獻</a></h3>
<ul>
<li>Wikipedia:<a href="http://en.wikipedia.org/wiki/Computer_chess">Computer chess</a></li>
<li>維基百科:<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E8%B1%A1%E6%A3%8B">電腦象棋</a></li>
<li>Wikipedia:<a href="http://en.wikipedia.org/wiki/Deep_Blue_(chess_computer)">Deep Blue</a></li>
<li>維基百科:<a href="http://zh.wikipedia.org/wiki/%E6%B7%B1%E8%97%8D_(%E9%9B%BB%E8%85%A6)">深藍</a></li>
<li>維基百科:<a href="http://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E8%B1%A1%E6%A3%8B">西洋棋</a></li>
<li>維基百科:<a href="http://zh.wikipedia.org/zh-tw/%E5%9B%B4%E6%A3%8B">圍棋</a></li>
<li><a href="http://chessprogramming.wikispaces.com/Learning">http://chessprogramming.wikispaces.com/Learning</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h2 id="實作五子棋程式"><a href="#實作五子棋程式">實作：五子棋程式</a></h2>
<h3 id="簡介-4"><a href="#簡介-4">簡介</a></h3>
<p>在本文中，我們設計了一個完全只是依賴「盤面評估函數」的五子棋程式，這個程式並沒有採用「Min-Max 對局搜尋法」，更沒有採用「Alpha-Beta 修剪法」，但是已經能夠與一般人對戰，有時候還可以贏得棋局。</p>
<p>以下是這個程式執行的一個畫面，我們採用命令列的設計方式，使用者下子時必須輸入格子的座標，該座標由兩個 16 進位字母組成，例如圖中的 62 代表下在第六列第二行的位置。</p>
<div class="figure">
<img src="../img/chess.jpg" alt="圖、五子棋程式的一個對局畫面" /><p class="caption">圖、五子棋程式的一個對局畫面</p>
</div>
<h3 id="程式實作-1"><a href="#程式實作-1">程式實作</a></h3>
<p>整個程式的實作只包含以下這個 chess.js 檔案，完整原始碼如下。</p>
<p>檔案：chess.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// 五子棋遊戲，單機命令列版</span>
<span class="co">//   人對人下：node chess P2P</span>
<span class="co">//   人對電腦：node chess P2C</span>
<span class="co">// 作者：陳鍾誠</span>
<span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;
<span class="kw">var</span> r = <span class="fu">require</span>(<span class="st">&#39;readline&#39;</span>).<span class="fu">createInterface</span>(<span class="ot">process</span>.<span class="fu">stdin</span>, <span class="ot">process</span>.<span class="fu">stdout</span>);

<span class="co">// 印出訊息，並取得輸入。</span>
<span class="kw">var</span> prompt = <span class="kw">function</span>(turn) {
  <span class="kw">var</span> msg = <span class="fu">format</span>(<span class="st">&#39;將 %s 下在 :    &#39;</span>, turn);
  <span class="ot">r</span>.<span class="fu">setPrompt</span>(msg);
  <span class="ot">r</span>.<span class="fu">prompt</span>();
}

<span class="kw">var</span> format = <span class="kw">function</span>() { <span class="co">// 字串格式化 </span>
  <span class="kw">return</span> <span class="ot">util</span>.<span class="ot">format</span>.<span class="fu">apply</span>(<span class="kw">null</span>, arguments);
}

<span class="co">// 棋盤物件</span>
<span class="kw">var</span> Board = <span class="kw">function</span>() {
  <span class="kw">this</span>.<span class="fu">m</span> = [];
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;<span class="dv">16</span>; r++) {
    <span class="kw">this</span>.<span class="fu">m</span>[r] = [];
    <span class="kw">for</span> (<span class="kw">var</span> c=<span class="dv">0</span>; c&lt;<span class="dv">16</span>; c++)
      <span class="kw">this</span>.<span class="fu">m</span>[r][c] = <span class="st">&#39;-&#39;</span>;
  }
}

<span class="co">// 將棋盤格式化成字串</span>
<span class="ot">Board</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {
  <span class="kw">var</span> str = <span class="st">&quot;  0 1 2 3 4 5 6 7 8 9 a b c d e f</span><span class="ch">\n</span><span class="st">&quot;</span>;
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;<span class="dv">16</span>; r++) {
    str += <span class="ot">r</span>.<span class="fu">toString</span>(<span class="dv">16</span>)+<span class="st">&quot; &quot;</span>+<span class="kw">this</span>.<span class="fu">m</span>[r].<span class="fu">join</span>(<span class="st">&quot; &quot;</span>)+<span class="st">&quot; &quot;</span>+<span class="ot">r</span>.<span class="fu">toString</span>(<span class="dv">16</span>)+<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
  }
  str += <span class="st">&quot;  0 1 2 3 4 5 6 7 8 9 a b c d e f</span><span class="ch">\n</span><span class="st">&quot;</span>;
  <span class="kw">return</span> str;
}

<span class="co">// 顯示棋盤</span>
<span class="ot">Board</span>.<span class="ot">prototype</span>.<span class="fu">show</span> = <span class="kw">function</span>() {
  <span class="fu">log</span>(<span class="kw">this</span>.<span class="fu">toString</span>());
}

<span class="co">// 以下為遊戲相關資料與函數</span>
<span class="co">// var zero = [ 0, 0, 0, 0, 0];</span>
<span class="co">// var inc  = [-2,-1, 0, 1, 2];</span>
<span class="co">// var dec  = [ 2, 1, 0,-1,-2];</span>
<span class="kw">var</span> z9   = [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>];
<span class="kw">var</span> i9   = [-<span class="dv">4</span>,-<span class="dv">3</span>,-<span class="dv">2</span>,-<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
<span class="kw">var</span> d9   = [ <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>,-<span class="dv">1</span>,-<span class="dv">2</span>,-<span class="dv">3</span>,-<span class="dv">4</span>];
<span class="kw">var</span> z5   = [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>];
<span class="kw">var</span> i2   = <span class="ot">i9</span>.<span class="fu">slice</span>(<span class="dv">2</span>,-<span class="dv">2</span>);
<span class="kw">var</span> d2   = <span class="ot">d9</span>.<span class="fu">slice</span>(<span class="dv">2</span>,-<span class="dv">2</span>);

<span class="co">// 檢查在 (r, c) 這一格，規則樣式 (dr, dc) 是否被滿足</span>
<span class="co">// dr, dc 的組合可用來代表「垂直 | , 水平 - , 下斜 \ , 上斜 /」。</span>
<span class="kw">var</span> patternCheck=<span class="kw">function</span>(board, turn, r, c, dr, dc) {
  <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; <span class="ot">dr</span>.<span class="fu">length</span>; i++) {
    <span class="kw">var</span> tr = <span class="ot">Math</span>.<span class="fu">round</span>(r+dr[i]);
    <span class="kw">var</span> tc = <span class="ot">Math</span>.<span class="fu">round</span>(c+dc[i]);
    <span class="kw">if</span> (tr&lt;<span class="dv">0</span> ||tr &gt; <span class="dv">15</span> || tc&lt;<span class="dv">0</span> || tc&gt;<span class="dv">15</span>)
      <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">var</span> v = <span class="ot">board</span>.<span class="fu">m</span>[tr][tc];
    <span class="kw">if</span> (v != turn) <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// 檢查是否下 turn 這個子的人贏了。</span>
<span class="kw">var</span> winCheck = <span class="kw">function</span>(board, turn) {
  <span class="kw">var</span> win = <span class="kw">false</span>;
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;<span class="dv">16</span>; r++) {
    <span class="kw">for</span> (<span class="kw">var</span> c=<span class="dv">0</span>; c&lt;<span class="dv">16</span>; c++) {
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, z5, i2)) <span class="co">// 垂直 | ;</span>
        win = <span class="kw">true</span>;
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, i2, z5)) <span class="co">// 水平 - ;</span>
        win = <span class="kw">true</span>;
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, i2, i2)) <span class="co">// 下斜 \ ;</span>
        win = <span class="kw">true</span>;
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, i2, d2)) <span class="co">// 上斜 / ;</span>
        win = <span class="kw">true</span>;
    }
  }
  <span class="kw">if</span> (win) {
    <span class="fu">log</span>(<span class="st">&quot;%s 贏了！&quot;</span>, turn);  <span class="co">// 如果贏了就印出贏了</span>
    <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>); <span class="co">// 然後離開。</span>
  }
  <span class="kw">return</span> win;
}

<span class="kw">var</span> peopleTurn = <span class="kw">function</span>(board, turn, line) {
  <span class="kw">var</span> r = <span class="fu">parseInt</span>(line[<span class="dv">0</span>], <span class="dv">16</span>); <span class="co">// 取得下子的列 r (row)</span>
  <span class="kw">var</span> c = <span class="fu">parseInt</span>(line[<span class="dv">1</span>], <span class="dv">16</span>); <span class="co">// 取得下子的行 c (column)</span>
  <span class="kw">if</span> (r&lt;<span class="dv">0</span> || r&gt;<span class="dv">15</span> || c&lt;<span class="dv">0</span> || c&gt;<span class="dv">15</span>) <span class="co">// 檢查是否超出範圍</span>
    <span class="kw">throw</span> <span class="st">&quot;(row, col) 超出範圍!&quot;</span>; <span class="co">// 若超出範圍就丟出例外，下一輪重新輸入。</span>
  <span class="kw">if</span> (<span class="ot">board</span>.<span class="fu">m</span>[r][c] != <span class="st">&#39;-&#39;</span>) <span class="co">// 檢查該位置是否已被佔據</span>
    <span class="kw">throw</span> <span class="fu">format</span>(<span class="st">&quot;(%s%s) 已經被佔領了!&quot;</span>, line[<span class="dv">0</span>], line[<span class="dv">1</span>]); <span class="co">// 若被佔據就丟出例外，下一輪重新輸入。</span>
  <span class="ot">board</span>.<span class="fu">m</span>[r][c] = turn; <span class="co">// 否則、將子下在使用者輸入的 (r,c) 位置</span>
}

<span class="kw">var</span> P2P=<span class="kw">function</span>(b, turn, line) {
  <span class="fu">peopleTurn</span>(b, turn, line);
  <span class="ot">b</span>.<span class="fu">show</span>();         <span class="co">// 顯示棋盤現況</span>
  <span class="fu">winCheck</span>(b, turn);
  <span class="kw">return</span> (turn == <span class="st">&#39;o&#39;</span>)?<span class="st">&#39;x&#39;</span>:<span class="st">&#39;o&#39;</span>; <span class="co">// 換對方下了。</span>
}

<span class="kw">var</span> attackScores = [ <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">30</span>, <span class="dv">100</span>, <span class="dv">500</span> ];
<span class="kw">var</span> guardScores  = [ <span class="dv">0</span>, <span class="dv">2</span>,  <span class="dv">9</span>, <span class="dv">25</span>,  <span class="dv">90</span>, <span class="dv">400</span> ];
<span class="kw">var</span> attack=<span class="dv">1</span>, guard=<span class="dv">2</span>;

<span class="kw">var</span> getScore = <span class="kw">function</span>(board, r, c, turn, mode) {
  <span class="kw">var</span> score = <span class="dv">0</span>;
  <span class="kw">var</span> mScores = (mode === attack)?attackScores:guardScores;
  <span class="ot">board</span>.<span class="fu">m</span>[r][c] = turn;
  <span class="kw">for</span> (<span class="kw">var</span> start = <span class="dv">0</span>; start &lt;= <span class="dv">4</span>; start++) {
    <span class="kw">for</span> (<span class="kw">var</span> len = <span class="dv">5</span>; len &gt;= <span class="dv">1</span>; len--) {
      <span class="kw">var</span> end = start+len;
      <span class="kw">var</span> zero = <span class="ot">z9</span>.<span class="fu">slice</span>(start, start+len);
      <span class="kw">var</span> inc  = <span class="ot">i9</span>.<span class="fu">slice</span>(start, start+len);
      <span class="kw">var</span> dec  = <span class="ot">d9</span>.<span class="fu">slice</span>(start, start+len);
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, zero, inc)) <span class="co">// 攻擊：垂直 | ;</span>
        score += mScores[len];
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, inc, zero)) <span class="co">// 攻擊：水平 - ;</span>
        score += mScores[len];
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, inc, inc)) <span class="co">// 攻擊：下斜 \ ;</span>
        score += mScores[len];
      <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, inc, dec)) <span class="co">// 攻擊：上斜 / ;</span>
        score += mScores[len];
    }
  }
  <span class="ot">board</span>.<span class="fu">m</span>[r][c] = <span class="st">&#39;-&#39;</span>;  
  <span class="kw">return</span> score;
}

<span class="kw">var</span> computerTurn = <span class="kw">function</span>(board, turn) {
  <span class="kw">var</span> best = { <span class="dt">r</span>:<span class="dv">0</span>, <span class="dt">c</span>:<span class="dv">0</span>, <span class="dt">score</span>:-<span class="dv">1</span> };
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;=<span class="dv">15</span>; r++) {
    <span class="kw">for</span> (<span class="kw">var</span> c=<span class="dv">0</span>; c&lt;=<span class="dv">15</span>; c++) {
      <span class="kw">if</span> (<span class="ot">board</span>.<span class="fu">m</span>[r][c] !== <span class="st">&#39;-&#39;</span>) 
        <span class="kw">continue</span>;
      <span class="kw">var</span> attackScore = <span class="fu">getScore</span>(board, r, c, <span class="st">&#39;x&#39;</span>, attack);  <span class="co">// 攻擊分數</span>
      <span class="kw">var</span> guardScore  = <span class="fu">getScore</span>(board, r, c, <span class="st">&#39;o&#39;</span>, guard);   <span class="co">// 防守分數</span>
      <span class="kw">var</span> score = attackScore+guardScore;
      <span class="kw">if</span> (score &gt; <span class="ot">best</span>.<span class="fu">score</span>) {
        <span class="ot">best</span>.<span class="fu">r</span> = r;
        <span class="ot">best</span>.<span class="fu">c</span> = c;
        <span class="ot">best</span>.<span class="fu">score</span> = score;
      }
    }
  }
  <span class="fu">log</span>(<span class="st">&quot;best=%j&quot;</span>, best);
  <span class="ot">board</span>.<span class="fu">m</span>[<span class="ot">best</span>.<span class="fu">r</span>][<span class="ot">best</span>.<span class="fu">c</span>] = turn; <span class="co">// 否則、將子下在使用者輸入的 (r,c) 位置</span>
}

<span class="kw">var</span> P2C=<span class="kw">function</span>(b, turn, line) {
  <span class="fu">peopleTurn</span>(b, <span class="st">&#39;o&#39;</span>, line);
  <span class="ot">b</span>.<span class="fu">show</span>();         <span class="co">// 顯示棋盤現況</span>
  <span class="fu">winCheck</span>(b, <span class="st">&#39;o&#39;</span>); <span class="co">// 檢查下了這子之後是否贏了！</span>
  <span class="fu">computerTurn</span>(b, <span class="st">&#39;x&#39;</span>, line);
  <span class="ot">b</span>.<span class="fu">show</span>();
  <span class="fu">winCheck</span>(b, <span class="st">&#39;x&#39;</span>);
  <span class="kw">return</span> <span class="st">&#39;o&#39;</span>;
}

<span class="kw">var</span> chess=<span class="kw">function</span>(doLine) {
  <span class="co">// 主程式開始</span>
  <span class="kw">var</span> b = <span class="kw">new</span> <span class="fu">Board</span>(); <span class="co">// 建立棋盤</span>
  <span class="ot">b</span>.<span class="fu">show</span>();            <span class="co">// 顯示棋盤</span>
  <span class="kw">var</span> turn = <span class="st">&#39;o&#39;</span>;      <span class="co">// o 先下</span>
  <span class="fu">prompt</span>(turn);        <span class="co">// 提示要求下子訊息，並接受輸入。</span>
  <span class="ot">r</span>.<span class="fu">on</span>(<span class="st">&#39;line&#39;</span>, <span class="kw">function</span>(line) { <span class="co">// 每當讀到一個字串時。</span>
    <span class="kw">try</span> {
      turn = <span class="fu">doLine</span>(b, turn, line);
    } <span class="kw">catch</span> (err) { <span class="co">// 若有丟出例外</span>
      <span class="fu">log</span>(err); <span class="co">// 則印出錯誤訊息。</span>
    }
    <span class="fu">prompt</span>(turn); <span class="co">// 提示要求下子訊息，並接受輸入。</span>
  }).<span class="fu">on</span>(<span class="st">&#39;close&#39;</span>, <span class="kw">function</span>() { <span class="co">// 輸入結束了</span>
    <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>); <span class="co">// 程式結束。</span>
  });
}

<span class="kw">if</span> (<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>] === <span class="st">&quot;P2P&quot;</span>) <span class="co">// 人對人下</span>
  <span class="fu">chess</span>(P2P);
<span class="kw">else</span> <span class="kw">if</span> (<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>] === <span class="st">&quot;P2C&quot;</span>) <span class="co">// 人對電腦下</span>
  <span class="fu">chess</span>(P2C);
<span class="kw">else</span> { <span class="co">// 命令下錯，提示訊息！</span>
  <span class="fu">log</span>(<span class="st">&quot;人對人下：node chess P2P</span><span class="ch">\n</span><span class="st">人對電腦：node chess P2C&quot;</span>);
  <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>);
}</code></pre>
<h3 id="執行結果-4"><a href="#執行結果-4">執行結果</a></h3>
<p>以下是一場對局的過程片段，您可以看到最後是 x 贏了，也就是人類贏了。</p>
<pre><code>C:\Dropbox\Public\web\ai\code\chess&gt;node chess P2C
  0 1 2 3 4 5 6 7 8 9 a b c d e f
0 - - - - - - - - - - - - - - - - 0
1 - - - - - - - - - - - - - - - - 1
2 - - - - - - - - - - - - - - - - 2
3 - - - - - - - - - - - - - - - - 3
4 - - - - - - - - - - - - - - - - 4
5 - - - - - - - - - - - - - - - - 5
6 - - - - - - - - - - - - - - - - 6
7 - - - - - - - - - - - - - - - - 7
8 - - - - - - - - - - - - - - - - 8
9 - - - - - - - - - - - - - - - - 9
a - - - - - - - - - - - - - - - - a
b - - - - - - - - - - - - - - - - b
c - - - - - - - - - - - - - - - - c
d - - - - - - - - - - - - - - - - d
e - - - - - - - - - - - - - - - - e
f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

將 o 下在 : 66
  0 1 2 3 4 5 6 7 8 9 a b c d e f
0 - - - - - - - - - - - - - - - - 0
1 - - - - - - - - - - - - - - - - 1
2 - - - - - - - - - - - - - - - - 2
3 - - - - - - - - - - - - - - - - 3
4 - - - - - - - - - - - - - - - - 4
5 - - - - - - - - - - - - - - - - 5
6 - - - - - - o - - - - - - - - - 6
7 - - - - - - - - - - - - - - - - 7
8 - - - - - - - - - - - - - - - - 8
9 - - - - - - - - - - - - - - - - 9
a - - - - - - - - - - - - - - - - a
b - - - - - - - - - - - - - - - - b
c - - - - - - - - - - - - - - - - c
d - - - - - - - - - - - - - - - - d
e - - - - - - - - - - - - - - - - e
f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

best={&quot;r&quot;:6,&quot;c&quot;:7,&quot;score&quot;:31}
  0 1 2 3 4 5 6 7 8 9 a b c d e f
0 - - - - - - - - - - - - - - - - 0
1 - - - - - - - - - - - - - - - - 1
2 - - - - - - - - - - - - - - - - 2
3 - - - - - - - - - - - - - - - - 3
4 - - - - - - - - - - - - - - - - 4
5 - - - - - - - - - - - - - - - - 5
6 - - - - - - o x - - - - - - - - 6
7 - - - - - - - - - - - - - - - - 7
8 - - - - - - - - - - - - - - - - 8
9 - - - - - - - - - - - - - - - - 9
a - - - - - - - - - - - - - - - - a
b - - - - - - - - - - - - - - - - b
c - - - - - - - - - - - - - - - - c
d - - - - - - - - - - - - - - - - d
e - - - - - - - - - - - - - - - - e
f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

...

best={&quot;r&quot;:6,&quot;c&quot;:3,&quot;score&quot;:144}
  0 1 2 3 4 5 6 7 8 9 a b c d e f
0 - - - - - - - - - - - - - - - - 0
1 - - - - - - - - - - - - - - - - 1
2 - - - - - - - - - - - - - - - - 2
3 - - - - - - - - - - - - - - - - 3
4 - - - - x - - - - - - - - - - - 4
5 - - - - - o - - - - - - - - - - 5
6 - - - x o o o x - - - - - - - - 6
7 - - - - - - - o - - - - - - - - 7
8 - - - - - - - - x - - - - - - - 8
9 - - - - - - - - - x - - - - - - 9
a - - - - - - - - - - - - - - - - a
b - - - - - - - - - - - - - - - - b
c - - - - - - - - - - - - - - - - c
d - - - - - - - - - - - - - - - - d
e - - - - - - - - - - - - - - - - e
f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f
...

  0 1 2 3 4 5 6 7 8 9 a b c d e f
0 - - - - - - - - - - - - - - - - 0
1 - - - - - - - - - - - - - - - - 1
2 - - - - - - - - - - - - - - - - 2
3 - - - - - - - - - - - - - - - - 3
4 - - - - x - - - - - - - - - - - 4
5 - - o - - o - - - - - - - - - - 5
6 - - o x o o o x - - - - - - - - 6
7 - - - - x o o o - - - - - - - - 7
8 - - - - - x - - x - - - - - - - 8
9 - - - - - - x - - x - - - - - - 9
a - - - - - - - x - - - - - - - - a
b - - - - - - - - - - - - - - - - b
c - - - - - - - - - - - - - - - - c
d - - - - - - - - - - - - - - - - d
e - - - - - - - - - - - - - - - - e
f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

x 贏了！</code></pre>
<h3 id="參考文獻-9"><a href="#參考文獻-9">參考文獻</a></h3>
<ul>
<li><a href="http://zh.wikipedia.org/zh-tw/%E4%BA%94%E5%AD%90%E6%A3%8B">維基百科：五子棋</a></li>
</ul>
<h2 id="電腦下棋的關鍵-min-max-對局搜尋與-alpha-beta-修剪算法"><a href="#電腦下棋的關鍵-min-max-對局搜尋與-alpha-beta-修剪算法">電腦下棋的關鍵： Min-Max 對局搜尋與 Alpha-Beta 修剪算法</a></h2>
<h3 id="前言-5"><a href="#前言-5">前言</a></h3>
<p>雖然我們在前文設計五子棋程式時單純使用了盤面評估函數就已經設計出了「具備自動下棋能力的電腦程式」，但是這種設計方法是不夠強大的。</p>
<p>電腦下棋要夠強大，通常必須採用「Min-Max 對局搜尋法」，如果能夠搜尋得愈深，電腦的棋力通常就會越高。</p>
<p>但是、對於電腦而言，每一層都有很多可能的下法，對手也可能會有很多的回應方式，這樣一層一層下去會有組合爆炸的問題。</p>
<p>舉例而言，假如對上文中有 256 格的棋盤而言，第一子的下法有 256 種，第二子的下法就有 255 種，....</p>
<p>因此若我們要進行 n 層的徹底搜尋，那在下第一步之前就必須探詢 256<em>255</em>...*(256-n+1) 這麼多種可能性，當 n 超過 10 層時，幾乎任何電腦都不可能在短短數秒內完成這樣的搜尋。</p>
<p>於是我們就必須減少蒐尋的可能性，這時我們可以採用著名的「 Alpha-Beta Cut」修剪法來減少蒐尋的空間大小。</p>
<p>讓我們先來瞭解一下何謂 「Min-Max 對局搜尋法」。</p>
<h3 id="min-max-對局搜尋法"><a href="#min-max-對局搜尋法">Min-Max 對局搜尋法</a></h3>
<p>在下棋的時候，如果要打敗對手，必須考量讓自己得分最多，且讓對手得分最少，Min-Max 正是根據這樣的想法而設計出來的。</p>
<p>必須注意的是，當電腦要下一子之前，當然會下讓自己得分最多的那一格，但是這很容易會落入對手的陷阱，因為得分最多的那一格很可能接下來失分更多。</p>
<p>於是、一個合理的想法是將所有層次分為「敵我雙方」兩類，我方下的那層得分越多越好，而對方下的那層失分越少越好。</p>
<p>而且、我們不能假設對方是個笨蛋，因此在每一層上，我們都必須認為「對方可能會下出讓我們失分最多的一步」，而我們必須盡可能選擇「最大失分最小化」的策略，這種想法就導出了「Min-Max 對局搜尋法」，以下是一個範例。</p>
<div class="figure">
<img src="../img/Minimax.jpg" alt="圖、Min-Max 對局搜尋法的範例" /><p class="caption">圖、Min-Max 對局搜尋法的範例</p>
</div>
<p>在上圖中、由於第 0 層代表我方下，所以我們取在第一層失分少的步驟，而第 1 層代表敵方下，所以假設他們也會採取對他們最有利的下法 (也就是對我們最不利的、讓我們失分多的) ，整張圖的推論邏輯就在這種 Min-Max 的過程中完成了。</p>
<p>必須補充說明的是，圖中的 -∞ 與 +∞ 通常代表該節點為樹葉節點，也就是整盤棋已經結束。換句話說、有人輸了或贏了。</p>
<p>演算法： Min-Max 對局搜尋</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">minimax</span>(node, depth, maximizingPlayer)
    <span class="kw">if</span> depth = <span class="dv">0</span> or node is a terminal node
        <span class="kw">return</span> the heuristic value of node
    <span class="kw">if</span> maximizingPlayer
        bestValue := -∞
        <span class="kw">for</span> each child of node
            val := <span class="fu">minimax</span>(child, depth - <span class="dv">1</span>, FALSE))
            bestValue := <span class="fu">max</span>(bestValue, val);
        <span class="kw">return</span> bestValue
    <span class="kw">else</span>
        bestValue := +∞
        <span class="kw">for</span> each child of node
            val := <span class="fu">minimax</span>(child, depth - <span class="dv">1</span>, TRUE))
            bestValue := <span class="fu">min</span>(bestValue, val);
        <span class="kw">return</span> bestValue

(* Initial call <span class="kw">for</span> maximizing player *)
<span class="fu">minimax</span>(origin, depth, TRUE)</code></pre>
<h3 id="alpha-beta-修剪法"><a href="#alpha-beta-修剪法">Alpha-Beta 修剪法</a></h3>
<p>您可以看到 Min-Max 對每個節點都進行遞迴展開，這種展開的數量是很龐大的，因此即使電腦非常快也展開不了幾層，所以我們必須透過「Alpha-Beta 修剪法」減少展開的數量，以下是一個範例。</p>
<div class="figure">
<img src="../img/AlphaBetaExample.jpg" alt="圖、 Alpha-Beta 修剪法的範例" /><p class="caption">圖、 Alpha-Beta 修剪法的範例</p>
</div>
<p>在上圖中，請注意上面 Min 層的 5 節點，您可以看到當該節點最左邊子樹的分數 5 已經計算出來後，由於 5 比 8 還小，因此不管後面的節點分數為多少，都不可能讓其父節點變得比 5 還要大，所以右邊的子樹都可以不用再計算了，這就是 Alpha-Beta 修剪法的原理。</p>
<p>「Alpha-Beta 修剪法」其實是「Min-Max 對局搜尋法」的一個修改版，主要是在 Min-Max 當中加入了 α 與 β 兩個紀錄值，用來做為是否要修剪的參考標準，演算法如下所示。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">alphabeta</span>(node, depth, α, β, maximizingPlayer)
     <span class="kw">if</span> depth = <span class="dv">0</span> or node is a terminal node
         <span class="kw">return</span> the heuristic value of node
     <span class="kw">if</span> maximizingPlayer
         <span class="kw">for</span> each child of node
             α := <span class="fu">max</span>(α, <span class="fu">alphabeta</span>(child, depth - <span class="dv">1</span>, α, β, FALSE))
             <span class="kw">if</span> β ≤ α
                 <span class="kw">break</span> (* β cut-off *)
         <span class="kw">return</span> α
     <span class="kw">else</span>
         <span class="kw">for</span> each child of node
             β := <span class="fu">min</span>(β, <span class="fu">alphabeta</span>(child, depth - <span class="dv">1</span>, α, β, TRUE))
             <span class="kw">if</span> β ≤ α
                 <span class="kw">break</span> (* α cut-off *)
         <span class="kw">return</span> β
         
(* Initial call <span class="kw">for</span> maximizing player *)
<span class="fu">alphabeta</span>(origin, depth, -∞, +∞, TRUE)</code></pre>
<h3 id="結語-8"><a href="#結語-8">結語</a></h3>
<p>當然、 Alpha-Beta 修剪法並不保證能將對局樹修剪得非常小，而且樹的大小會與拜訪的順序有關，如果希望樹可以比較小的話，應當從「對我方分數最高、對敵方分數最低」的節點開始處理，這樣才能有效的降低整棵對局搜尋樹的大小。</p>
<h3 id="參考文獻-10"><a href="#參考文獻-10">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Minimax">Wikipedia:Minimax</a></li>
<li><a href="http://en.wikipedia.org/wiki/Alpha-beta_pruning">Wikipedia:Alpha–beta pruning</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org">維基百科</a>，採用創作共用的 [姓名標示、相同方式分享] 授權】</p>
<h1 id="邏輯推論與專家系統"><a href="#邏輯推論與專家系統">邏輯推論與專家系統</a></h1>
<h2 id="布林邏輯"><a href="#布林邏輯">布林邏輯</a></h2>
<p>在布林邏輯中，只有用來代表真假值的簡單變數，像是 A, B, C, X, Y, Z .... 等，所以邏輯算式看來通常如下：</p>
<ul>
<li>P &amp; (P=&gt;Q) =&gt; Q.</li>
<li>A &amp; B &amp; C =&gt; D | E.</li>
<li>-(A &amp; B) &lt;=&gt; -A | -B.</li>
</ul>
<p>這種布林命題邏輯裏沒有函數的概念，只有簡單的命題 (Proposition)，因此布林邏輯也稱為命題邏輯 (Propositional Logic)。</p>
<h2 id="謂詞邏輯"><a href="#謂詞邏輯">謂詞邏輯</a></h2>
<p>而在謂詞邏輯裏，則有「布林函數」的概念，因此其表達能力較強，例如以下是一些謂詞邏輯的範例。</p>
<ul>
<li>Parent(x,y) &lt;= Father(x,y).</li>
<li>Parent(John, Johnson).</li>
<li>Ancestor(x,y) &lt;= Parent(x,y).</li>
<li>Ancestor(x,y) &lt;= Ancestor(x,z) &amp; Parent(z,y).</li>
</ul>
<p>您可以看到在這種邏輯系統裏，有「布林變數」的概念 (像是 x, y, z 等等)，也有函數的概念，像是 Parent(), Father(), Ancestor() 等等。</p>
<h2 id="一階邏輯"><a href="#一階邏輯">一階邏輯</a></h2>
<p>在上述這種謂詞邏輯系統中，如果我們加上 <img src="../timg/8b141f94d437.jpg" /> (對於所有) 或 <img src="../timg/297f1fa5c654.jpg" /> (存在) 這兩個變數限定符號，而其中的謂詞不可以是變項，而必須要是常項，這種邏輯就稱為一階邏輯。</p>
<ul>
<li><img src="../timg/514fcee4eee7.jpg" /> ; 人都是會死的。</li>
<li><img src="../timg/622fa223aee6.jpg" /> ; 蘇格拉底是人。</li>
<li><img src="../timg/66f17dc26b90.jpg" /> ; 蘇格拉底會死。</li>
</ul>
<p>當然、規則可以更複雜，像是以下這個範例，就說明了「存在一些人可以永遠被欺騙」。</p>
<ul>
<li><img src="../timg/d37038cf1d92.jpg" title="fig:" /></li>
</ul>
<h2 id="二階邏輯"><a href="#二階邏輯">二階邏輯</a></h2>
<p>如果一階邏輯中的謂詞，放寬成可以是變項的話 (這些變項可以加上 <img src="../timg/8b141f94d437.jpg" /> 與 <img src="../timg/32ff223f4b92.jpg" /> 等符號的約束)，那就變成了二階邏輯，以下是一些二階邏輯的規則範例。</p>
<ul>
<li><img src="../timg/d12b91ab3a7b.jpg" /><br /></li>
<li><img src="../timg/41d3eb0c5f8c.jpg" /></li>
<li><img src="../timg/d01e95cc8ac8.jpg" /> ; 數學歸納法。</li>
</ul>
<h2 id="專家系統"><a href="#專家系統">專家系統</a></h2>
<p>透過邏輯推論的方式，我們很容易就可以建構出一種「問題-回答」系統，這種系統會根據邏輯規則進行推論，讓您透過對話的方式得到問題的答案，以下是一個「動物分類專家系統」的範例。</p>
<p>動物世界規則庫 : animal.kb</p>
<pre><code>哺乳類 &lt;= 有毛. 
哺乳類 &lt;= 泌乳. 
鳥類   &lt;= 有羽毛. 
鳥類   &lt;= 會飛 &amp; 生蛋. 
食肉類 &lt;= 哺乳類 &amp; 吃肉.
食肉類 &lt;= 有爪 &amp; 利齒 &amp; 兩眼前視.
有蹄類 &lt;= 哺乳類 &amp; 有蹄.
偶蹄類 &lt;= 哺乳類 &amp; 反芻.
獵豹   &lt;= 哺乳類 &amp; 吃肉 &amp; 斑點.
老虎   &lt;= 哺乳類 &amp; 吃肉 &amp; 條紋.
長頸鹿 &lt;= 有蹄類 &amp; 長腿 &amp; 斑點.
斑馬   &lt;= 有蹄類 &amp; 條紋.
鴕鳥   &lt;= 鳥類 &amp; 長腿.</code></pre>
<p>此時如果您在對話中描述某些事實，例如以下的範例：</p>
<pre><code>問題：請問該動物有毛嗎? (1. 有毛 2. 沒毛)
請選擇 =&gt; 1

問題：請問該動物吃肉嗎? (1. 吃肉 2. 不吃肉)
請選擇 =&gt; 1

問題：請問該動物有條紋或斑點嗎? (1. 有條紋 2. 有斑點 3. 兩者皆無)
請選擇 =&gt; 1

回答：您所描述的動物應該是「老虎」。

## 推理引擎

我們可以用程式撰寫出「布林邏輯、謂詞邏輯、一階邏輯」等系統的推理引擎。

推理引擎的設計方法大致可分為下列三類：

1. 前向推論： 從「已知事實」開始不斷的進行規則比對，推論出所有目前能推論出的「新事實」，然後將這些新事實加入「新知識庫」中，直到推論出終端結果為止。

舉例而言、當我們在「動物規則庫」的世界裏，輸入「有毛」時，則會推論出「哺乳類」這個結論。

此時、如果再輸入「吃肉」這個「新事實」，那麼由於「哺乳類」已經在「新知識庫」中了，所以就會推論出「食肉類」。

接著、如果我們再度輸入「條紋」這個「新事實」，那麼推論系統就會推論出「老虎」這個結論。

2. 後向推論：從問題開始，透過不斷的反向連結，產生新的問題，一但某規則的所有問題都已經被滿足，則可推出該規則的結論。

舉例而言、假如有一個「家族世界」的規則庫如下。
</code></pre>
<p>parent(x,y) &lt;= father(x,y). parent(x,y) &lt;= mother(x,y). ancestor(x,y) &lt;= parent(x,y). ancestor(x,z) &lt;= ancestor(x,y) &amp; parent(y,z).</p>
<p>father(John, Johnson). mother(Mary, Johnson). father(George, John). father(John, Jake). ```</p>
<p>當我們輸入 ancestor(p, Johnson) 時，則後向堆論引擎與 ancestor(x,z) 比對符合後會觸發下列規則：</p>
<pre><code>ancestor(x,y) &lt;= parent(x,y).</code></pre>
<p>然後將 (x=p, y=Johnson) 綁定後，企圖尋找前題 parent(x,Johnson).</p>
<p>接著 parent(x,Johnson) 會再度觸發下列規則：</p>
<pre><code>parent(x,y)   &lt;= father(x,y).</code></pre>
<p>於是再度尋找前題 father(x,Johnson)。</p>
<p>然後 father(x,Johnson) 會比對到 father(John, Johnson) 這個事實，於是將 x 與 John 綁定，得到 father(x=John, Johnson) 的結果。</p>
<p>接著進行回溯，得到 parent(x=John, y=Johnson)，再回溯規則 <code>ancestor(x,y) &lt;= parent(x,y)</code> 得到新事實 ancestor(John, Johnson)。</p>
<p>同樣的，系統也能透過類似的程序推論出 ancestor(Mary, Johnson) , ancestor(Mary, Johnson), ancestor(George, John) 等新事實。</p>
<p>更進一步的，後向推論還可以透過下列規則得到更多更深的推論：</p>
<pre><code>ancestor(x,z) &lt;= ancestor(x,y) &amp; parent(y,z).</code></pre>
<p>在上述新事實的基礎上，系統可以進行下列嘗試</p>
<pre><code>ancestor(x=George,z=Johnson) &lt;= ancestor(x=George,y=John) &amp; parent(y=John,z=Johnson).</code></pre>
<p>然後得到「祖父級」的推論結果，也就是 ancestor(George, Johnson)。</p>
<ol start="3" style="list-style-type: decimal">
<li>第三種推論方法是採用 refutation 的方式，這是由羅賓遜 (John Alan Robinson) 於 1965 年所提出來的，可以用在「布林邏輯、謂詞邏輯、甚至是一階邏輯」上，而且這種方法在理論上是可以推論出所有事實的，因此是一種具有「完備性」(Complete) 的推論方法。</li>
</ol>
<p>Refutation 推論法是一種反證法，任何一階邏輯的算式 P 只要在系統 S 當中是真的，只要將 -P 加入該系統 S 中，就可以經由反證法導出矛盾。如果 P 在系統 S 當中不是真的，那麼將 P 加入 S 當中就無法導出矛盾。</p>
<p>Refutation 反證法是依靠一個稱為 resolution 的邏輯規則，該規則如下所示：</p>
<div class="figure">
<img src="../timg/21fa3adc303f.jpg" />
</div>
<p>假如我們將上述算式中的 <img src="../timg/b4ffcfd79743.jpg" /> 寫為 A，將 <img src="../timg/9018c1f2e831.jpg" /> 寫為 B，則上述算式可以改寫如下：</p>
<div class="figure">
<img src="../timg/940130743f3d.jpg" />
</div>
<p>透過這樣的方式，我們可以檢驗任何一個規則 P 是否為真，只要將 -P 加入系統中，看看最後是否會導出空集合 (代表矛盾) 就行了。</p>
<p>如果 -P 加入後導出了矛盾，那就代表 P 是個真理，於是我們就可以將 P 加入「新的事實庫」當中。</p>
<p>可惜的是、Refutation 推論法非常耗費時間，而且不一定會停下來，有可能會造成當機的情況，因此採用 Refutation 推論法的引擎真的很少見，至少筆者還沒有見過。</p>
<p>有了以上的認知之後，我們就可以開始實作推理引擎了。</p>
<p>接下來我們會用 JavaScript + node.js 來設計「邏輯推論引擎與專家系統」，用程式人的角度來看看上述理論的真正意義吧！</p>
<p>我們首先會設計一個「布林邏輯推論引擎」，然後用這個引擎建構一個「動物世界的專家系統」。</p>
<p>接著我們會擴充到「謂詞邏輯」上，設計一個「謂詞邏輯推論引擎」，然後再用這個引擎建構出一個「家族關係的專家系統」。</p>
<h2 id="實作布林邏輯的推論引擎"><a href="#實作布林邏輯的推論引擎">實作：布林邏輯的推論引擎</a></h2>
<h3 id="程式碼推理引擎"><a href="#程式碼推理引擎">程式碼：推理引擎</a></h3>
<pre class="sourceCode javascript"><code class="sourceCode javascript">檔案：<span class="ot">kb</span>.<span class="fu">js</span> (Knowledge Base 的簡寫)

<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="kw">var</span> kb = <span class="kw">function</span>() {
  <span class="kw">this</span>.<span class="fu">rules</span> = [];
  <span class="kw">this</span>.<span class="fu">facts</span> = {};
  <span class="kw">this</span>.<span class="fu">dict</span>  = {};
}

<span class="kw">var</span> kbp = <span class="ot">kb</span>.<span class="fu">prototype</span>;

<span class="ot">kbp</span>.<span class="fu">load</span> = <span class="kw">function</span>(code) {
  <span class="kw">var</span> lines = <span class="ot">code</span>.<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[</span><span class="fl">\.</span><span class="bn">]</span><span class="fl">+</span><span class="ot"> </span><span class="fl">?</span><span class="ot">/</span>);
  <span class="fu">log</span>(<span class="st">&quot;%j&quot;</span>, lines);
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> lines) {
    <span class="kw">if</span> (lines[i].<span class="fu">trim</span>().<span class="fu">length</span> &gt; <span class="dv">0</span>)
      <span class="kw">this</span>.<span class="fu">addRule</span>(lines[i]);
  }
}
  
<span class="ot">kbp</span>.<span class="fu">isFact</span>=<span class="kw">function</span>(term) {
  <span class="kw">if</span> (<span class="ot">term</span>.<span class="fu">length</span> == <span class="dv">0</span>)
    <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">facts</span>[term];
}

<span class="ot">kbp</span>.<span class="fu">check</span> = <span class="kw">function</span>(rule) {
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="ot">rule</span>.<span class="fu">terms</span>) {
    <span class="kw">var</span> term = <span class="ot">rule</span>.<span class="fu">terms</span>[i].<span class="fu">trim</span>();
    <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">isFact</span>(term))
      <span class="kw">continue</span>;
    <span class="kw">else</span>
      <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="ot">kbp</span>.<span class="fu">addFact</span> = <span class="kw">function</span>(term) {
  <span class="kw">this</span>.<span class="fu">facts</span>[term] = <span class="kw">true</span>;
  <span class="fu">log</span>(<span class="st">&quot;addFact(%s)&quot;</span>, term);
}

<span class="ot">kbp</span>.<span class="fu">addRule</span> = <span class="kw">function</span>(line) {
  <span class="kw">var</span> m = <span class="ot">line</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^(</span><span class="bn">[</span><span class="fl">^</span><span class="bn">&lt;=]</span><span class="fl">*)(</span><span class="ot">&lt;=</span><span class="fl">(</span><span class="ot">.</span><span class="fl">*))?$</span><span class="ot">/</span>);
  <span class="kw">var</span> head = (m[<span class="dv">1</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">1</span>].<span class="fu">trim</span>();
  <span class="kw">var</span> terms= (m[<span class="dv">3</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">3</span>].<span class="fu">trim</span>().<span class="fu">split</span>(<span class="ot">/&amp;</span><span class="fl">+</span><span class="ot">/</span>);
  <span class="fu">log</span>(<span class="st">&quot;rule:head=%s terms=%j&quot;</span>, head, terms);
  <span class="kw">var</span> rule = { <span class="dt">head</span>:head, <span class="dt">terms</span>:terms, <span class="dt">satisfy</span>:<span class="kw">false</span> };
  <span class="kw">this</span>.<span class="ot">rules</span>.<span class="fu">push</span>(rule);
  <span class="kw">this</span>.<span class="fu">dict</span>[head] = { <span class="dt">headHits</span>: [rule], <span class="dt">bodyHits</span>:[] };  
}

<span class="ot">kbp</span>.<span class="fu">forwardChaining</span> = <span class="kw">function</span>() {
  <span class="kw">do</span> {
    <span class="kw">var</span> anySatisfy = <span class="kw">false</span>;
    <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">rules</span>) {
      <span class="kw">var</span> rule = <span class="kw">this</span>.<span class="fu">rules</span>[i];
      <span class="kw">if</span> (!<span class="ot">rule</span>.<span class="fu">satisfy</span>) {
        <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">check</span>(rule)) {
          <span class="kw">this</span>.<span class="fu">addFact</span>(<span class="ot">rule</span>.<span class="fu">head</span>);
          <span class="ot">rule</span>.<span class="fu">satisfy</span> = <span class="kw">true</span>;
          anySatisfy = <span class="kw">true</span>;
        }
      }
    }
  } <span class="kw">while</span> (anySatisfy);
  <span class="fu">log</span>(<span class="st">&quot;facts=%j&quot;</span>, <span class="ot">Object</span>.<span class="fu">keys</span>(<span class="kw">this</span>.<span class="fu">facts</span>));
}

<span class="ot">kbp</span>.<span class="fu">trySatisfy</span> = <span class="kw">function</span>(goal) {
  <span class="fu">log</span>(<span class="st">&quot;trySatisfy(%s)&quot;</span>, goal);
  <span class="kw">var</span> word = <span class="kw">this</span>.<span class="fu">dict</span>[goal];
  <span class="kw">if</span> (word == <span class="kw">null</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">var</span> headHits = <span class="ot">word</span>.<span class="fu">headHits</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> headHits) {
    <span class="kw">var</span> rule = headHits[i];
    <span class="kw">if</span> (<span class="ot">rule</span>.<span class="fu">satisfy</span>) {
      <span class="kw">this</span>.<span class="fu">addFact</span>(goal);
      <span class="kw">return</span> <span class="kw">true</span>;
    } <span class="kw">else</span> {
      <span class="kw">var</span> isSatisfy = <span class="kw">true</span>;
      <span class="kw">for</span> (<span class="kw">var</span> ti <span class="kw">in</span> <span class="ot">rule</span>.<span class="fu">terms</span>) {
        <span class="kw">var</span> term = <span class="ot">rule</span>.<span class="fu">terms</span>[ti];
        <span class="kw">var</span> satisfy = <span class="kw">this</span>.<span class="fu">trySatisfy</span>(term);
        <span class="kw">if</span> (!satisfy) isSatisfy = <span class="kw">false</span>;
      }
      <span class="ot">rule</span>.<span class="fu">satisfy</span> = isSatisfy;
      <span class="kw">if</span> (isSatisfy) {
        <span class="kw">this</span>.<span class="fu">addFact</span>(goal);
        <span class="kw">return</span> <span class="kw">true</span>;
      }
    }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="ot">kbp</span>.<span class="fu">backwardChaining</span> = <span class="kw">function</span>(goal) {
  <span class="kw">this</span>.<span class="fu">trySatisfy</span>(goal);
  <span class="fu">log</span>(<span class="st">&quot;facts=%j&quot;</span>, <span class="ot">Object</span>.<span class="fu">keys</span>(<span class="kw">this</span>.<span class="fu">facts</span>));
}

<span class="ot">module</span>.<span class="fu">exports</span> = kb;</code></pre>
<h3 id="簡易的測試程式"><a href="#簡易的測試程式">簡易的測試程式</a></h3>
<p>檔案：kbTest.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用檔案物件</span>
<span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./kb&#39;</span>);

<span class="kw">var</span> code = <span class="st">&quot;A&lt;=B. B&lt;=C&amp;D. C&lt;=E. D&lt;=F. E. F. Z&lt;=C&amp;D&amp;G.&quot;</span>;
<span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
<span class="ot">kb1</span>.<span class="fu">load</span>(code);
<span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();
<span class="co">// kb1.backwardChaining(&quot;A&quot;);</span>
<span class="co">// kb1.backwardChaining(&quot;Z&quot;);</span></code></pre>
<h3 id="執行結果-5"><a href="#執行結果-5">執行結果</a></h3>
<pre><code>C:\Dropbox\Public\web\ai\code\KB&gt;node kbTest
[&quot;A&lt;=B&quot;,&quot;B&lt;=C&amp;D&quot;,&quot;C&lt;=E&quot;,&quot;D&lt;=F&quot;,&quot;E&quot;,&quot;F&quot;,&quot;Z&lt;=C&amp;D&amp;G&quot;,&quot;&quot;]
rule:head=A terms=[&quot;B&quot;]
rule:head=B terms=[&quot;C&quot;,&quot;D&quot;]
rule:head=C terms=[&quot;E&quot;]
rule:head=D terms=[&quot;F&quot;]
rule:head=E terms=&quot;&quot;
rule:head=F terms=&quot;&quot;
rule:head=Z terms=[&quot;C&quot;,&quot;D&quot;,&quot;G&quot;]
addFact(E)
addFact(F)
addFact(C)
addFact(D)
addFact(B)
addFact(A)
facts=[&quot;E&quot;,&quot;F&quot;,&quot;C&quot;,&quot;D&quot;,&quot;B&quot;,&quot;A&quot;]</code></pre>
<h3 id="結語-9"><a href="#結語-9">結語</a></h3>
<p>以上我們用 JavaScript 實作了一個簡易的布林邏輯推論引擎，採用洪氏邏輯的語法，以及前向推論 (forwardChaining) 的方式。(程式中也有附上後向推論的函數 backwardChaining，讀者可自行測試)。</p>
<h2 id="實作專家系統---前向推論程式"><a href="#實作專家系統---前向推論程式">實作：專家系統 - 前向推論程式</a></h2>
<p>以下是一個代表鴕鳥的動物世界規則庫。</p>
<p>規則庫：animal_ostrich.kb</p>
<pre><code>哺乳類 &lt;= 有毛. 
哺乳類 &lt;= 泌乳. 
鳥類   &lt;= 有羽毛. 
鳥類   &lt;= 會飛 &amp; 生蛋. 
食肉類 &lt;= 哺乳類 &amp; 吃肉.
食肉類 &lt;= 有爪 &amp; 利齒 &amp; 兩眼前視.
有蹄類 &lt;= 哺乳類 &amp; 有蹄.
偶蹄類 &lt;= 哺乳類 &amp; 反芻.
獵豹   &lt;= 哺乳類 &amp; 吃肉 &amp; 斑點.
老虎   &lt;= 哺乳類 &amp; 吃肉 &amp; 條紋.
長頸鹿 &lt;= 有蹄類 &amp; 長腿 &amp; 斑點.
斑馬   &lt;= 有蹄類 &amp; 條紋.
鴕鳥   &lt;= 鳥類 &amp; 長腿.

會飛. 
生蛋. 
長腿. </code></pre>
<p>接著我們採用前述的「布林邏輯推論引擎 kb.js」，透過讀入規則檔並進行推論的方式，設計出「前向推論」的程式。</p>
<p>檔案：kbReason.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用檔案物件</span>
<span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./kb&#39;</span>);

<span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
<span class="kw">var</span> code = <span class="ot">fs</span>.<span class="fu">readFileSync</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>], <span class="st">&quot;utf8&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\n</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>); <span class="co">// 讀取檔案</span>

<span class="ot">kb1</span>.<span class="fu">load</span>(code);
<span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();</code></pre>
<p>以下是上述「隱含鴕鳥前提」的規則庫經過「前向布林引擎」推論後得到的執行結果。</p>
<pre><code>C:\Dropbox\Public\web\ai\code\KB&gt;node kbReason animal_ostrich.kb
[&quot;哺乳類 &lt;= 有毛&quot;,&quot;哺乳類 &lt;= 泌乳&quot;,&quot;鳥類   &lt;= 有羽毛&quot;,&quot;鳥類   &lt;= 會飛 &amp; 生蛋&quot;,&quot;
食肉類 &lt;= 哺乳類 &amp; 吃肉&quot;,&quot;食肉類 &lt;= 有爪 &amp; 利齒 &amp; 兩眼前視&quot;,&quot;有蹄類 &lt;= 哺乳類 &amp;
有蹄&quot;,&quot;偶蹄類 &lt;= 哺乳類 &amp; 反芻&quot;,&quot;獵豹   &lt;= 哺乳類 &amp; 吃肉 &amp; 斑點&quot;,&quot;老虎   &lt;= 哺乳
類 &amp; 吃肉 &amp; 條紋&quot;,&quot;長頸鹿 &lt;= 有蹄類 &amp; 長腿 &amp; 斑點&quot;,&quot;斑馬   &lt;= 有蹄類 &amp; 條紋&quot;,&quot;鴕
鳥   &lt;= 鳥類 &amp; 長腿&quot;,&quot;會飛&quot;,&quot;生蛋&quot;,&quot;長腿&quot;,&quot;&quot;]
rule:head=哺乳類 terms=[&quot;有毛&quot;]
rule:head=哺乳類 terms=[&quot;泌乳&quot;]
rule:head=鳥類 terms=[&quot;有羽毛&quot;]
rule:head=鳥類 terms=[&quot;會飛 &quot;,&quot; 生蛋&quot;]
rule:head=食肉類 terms=[&quot;哺乳類 &quot;,&quot; 吃肉&quot;]
rule:head=食肉類 terms=[&quot;有爪 &quot;,&quot; 利齒 &quot;,&quot; 兩眼前視&quot;]
rule:head=有蹄類 terms=[&quot;哺乳類 &quot;,&quot; 有蹄&quot;]
rule:head=偶蹄類 terms=[&quot;哺乳類 &quot;,&quot; 反芻&quot;]
rule:head=獵豹 terms=[&quot;哺乳類 &quot;,&quot; 吃肉 &quot;,&quot; 斑點&quot;]
rule:head=老虎 terms=[&quot;哺乳類 &quot;,&quot; 吃肉 &quot;,&quot; 條紋&quot;]
rule:head=長頸鹿 terms=[&quot;有蹄類 &quot;,&quot; 長腿 &quot;,&quot; 斑點&quot;]
rule:head=斑馬 terms=[&quot;有蹄類 &quot;,&quot; 條紋&quot;]
rule:head=鴕鳥 terms=[&quot;鳥類 &quot;,&quot; 長腿&quot;]
rule:head=會飛 terms=&quot;&quot;
rule:head=生蛋 terms=&quot;&quot;
rule:head=長腿 terms=&quot;&quot;
addFact(會飛)
addFact(生蛋)
addFact(長腿)
addFact(鳥類)
addFact(鴕鳥)
facts=[&quot;會飛&quot;,&quot;生蛋&quot;,&quot;長腿&quot;,&quot;鳥類&quot;,&quot;鴕鳥&quot;]</code></pre>
<p>您可以看到上述系統利用「會飛. 生蛋. 長腿. 」等三個屬性，推論出了「鳥類、鴕鳥」這兩個結論。</p>
<p>這個結果符合我們的預期，因此該程式的運作是正常的。</p>
<h2 id="實作專家系統---互動推論程式"><a href="#實作專家系統---互動推論程式">實作：專家系統 - 互動推論程式</a></h2>
<p>當然、我們不一定要像前述範例那樣，將「隱含前提」直接寫死在規則庫當中。</p>
<p>我們也可以透過互動的方式讓使用者輸入這些「隱含前提」，逐步的讓「推理引擎」推論出結果，以下是這種互動式推論的一個執行範例。</p>
<p>首先、我們只要將以下的動物世界推論規則放在 animal.kb 規則檔中。</p>
<pre><code>哺乳類 &lt;= 有毛. 
哺乳類 &lt;= 泌乳. 
鳥類   &lt;= 有羽毛. 
鳥類   &lt;= 會飛 &amp; 生蛋. 
食肉類 &lt;= 哺乳類 &amp; 吃肉.
食肉類 &lt;= 有爪 &amp; 利齒 &amp; 兩眼前視.
有蹄類 &lt;= 哺乳類 &amp; 有蹄.
偶蹄類 &lt;= 哺乳類 &amp; 反芻.
獵豹   &lt;= 哺乳類 &amp; 吃肉 &amp; 斑點.
老虎   &lt;= 哺乳類 &amp; 吃肉 &amp; 條紋.
長頸鹿 &lt;= 有蹄類 &amp; 長腿 &amp; 斑點.
斑馬   &lt;= 有蹄類 &amp; 條紋.
鴕鳥   &lt;= 鳥類 &amp; 長腿.</code></pre>
<p>接著撰寫一個通用的推論程式 kbQuery.js，其原始碼如下所示：</p>
<p>檔案：kbQuery.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用檔案物件</span>
<span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./kb&#39;</span>);

<span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
<span class="kw">var</span> code = <span class="ot">fs</span>.<span class="fu">readFileSync</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>], <span class="st">&quot;utf8&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\n</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>); <span class="co">// 讀取檔案</span>
<span class="ot">kb1</span>.<span class="fu">load</span>(code);
<span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();

<span class="kw">var</span> r = <span class="fu">require</span>(<span class="st">&#39;readline&#39;</span>).<span class="fu">createInterface</span>(<span class="ot">process</span>.<span class="fu">stdin</span>, <span class="ot">process</span>.<span class="fu">stdout</span>);
<span class="ot">r</span>.<span class="fu">setPrompt</span>(<span class="st">&#39;?- &#39;</span>);
<span class="ot">r</span>.<span class="fu">prompt</span>();

<span class="ot">r</span>.<span class="fu">on</span>(<span class="st">&#39;line&#39;</span>, <span class="kw">function</span>(line) {
  <span class="kw">var</span> term = <span class="ot">line</span>.<span class="fu">trim</span>();
  <span class="ot">kb1</span>.<span class="fu">addFact</span>(term);
  <span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();
  <span class="ot">r</span>.<span class="fu">prompt</span>();
}).<span class="fu">on</span>(<span class="st">&#39;close&#39;</span>, <span class="kw">function</span>() {
  <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>);
});</code></pre>
<p>然後、我們就可以透過互動的方式，輸入指定的前提，推理系統將會適時推論出我們想要查詢的動物，以下是一個執行的過程範例。</p>
<pre><code>C:\Dropbox\Public\web\ai\code\KB&gt;node kbQuery animal.kb
[&quot;哺乳類 &lt;= 有毛&quot;,&quot;哺乳類 &lt;= 泌乳&quot;,&quot;鳥類   &lt;= 有羽毛&quot;,&quot;鳥類   &lt;= 會飛 &amp; 生蛋&quot;,&quot;
食肉類 &lt;= 哺乳類 &amp; 吃肉&quot;,&quot;食肉類 &lt;= 有爪 &amp; 利齒 &amp; 兩眼前視&quot;,&quot;有蹄類 &lt;= 哺乳類 &amp;
有蹄&quot;,&quot;偶蹄類 &lt;= 哺乳類 &amp; 反芻&quot;,&quot;獵豹   &lt;= 哺乳類 &amp; 吃肉 &amp; 斑點&quot;,&quot;老虎   &lt;= 哺乳
類 &amp; 吃肉 &amp; 條紋&quot;,&quot;長頸鹿 &lt;= 有蹄類 &amp; 長腿 &amp; 斑點&quot;,&quot;斑馬   &lt;= 有蹄類 &amp; 條紋&quot;,&quot;鴕
鳥   &lt;= 鳥類 &amp; 長腿&quot;,&quot;&quot;]
rule:head=哺乳類 terms=[&quot;有毛&quot;]
rule:head=哺乳類 terms=[&quot;泌乳&quot;]
rule:head=鳥類 terms=[&quot;有羽毛&quot;]
rule:head=鳥類 terms=[&quot;會飛 &quot;,&quot; 生蛋&quot;]
rule:head=食肉類 terms=[&quot;哺乳類 &quot;,&quot; 吃肉&quot;]
rule:head=食肉類 terms=[&quot;有爪 &quot;,&quot; 利齒 &quot;,&quot; 兩眼前視&quot;]
rule:head=有蹄類 terms=[&quot;哺乳類 &quot;,&quot; 有蹄&quot;]
rule:head=偶蹄類 terms=[&quot;哺乳類 &quot;,&quot; 反芻&quot;]
rule:head=獵豹 terms=[&quot;哺乳類 &quot;,&quot; 吃肉 &quot;,&quot; 斑點&quot;]
rule:head=老虎 terms=[&quot;哺乳類 &quot;,&quot; 吃肉 &quot;,&quot; 條紋&quot;]
rule:head=長頸鹿 terms=[&quot;有蹄類 &quot;,&quot; 長腿 &quot;,&quot; 斑點&quot;]
rule:head=斑馬 terms=[&quot;有蹄類 &quot;,&quot; 條紋&quot;]
rule:head=鴕鳥 terms=[&quot;鳥類 &quot;,&quot; 長腿&quot;]
facts=[]
?- 有毛
addFact(有毛)
addFact(哺乳類)
facts=[&quot;有毛&quot;,&quot;哺乳類&quot;]
?- 吃肉
addFact(吃肉)
addFact(食肉類)
facts=[&quot;有毛&quot;,&quot;哺乳類&quot;,&quot;吃肉&quot;,&quot;食肉類&quot;]
?- 條紋
addFact(條紋)
addFact(老虎)
facts=[&quot;有毛&quot;,&quot;哺乳類&quot;,&quot;吃肉&quot;,&quot;食肉類&quot;,&quot;條紋&quot;,&quot;老虎&quot;]
?-</code></pre>
<p>您可以看到當我們輸入了「有毛、吃肉、條紋」等三個屬性之後，系統推論出了「老虎」這個結論，這正式動物世界專家系統所應該傳回的結果，不是嗎？</p>
<h2 id="實作謂詞邏輯的推論引擎"><a href="#實作謂詞邏輯的推論引擎">實作：謂詞邏輯的推論引擎</a></h2>
<p>接著、讓我們將上述的「布林推論引擎」擴充，成為一個可以包含「布林函數」的「謂詞邏輯」推論引擎。</p>
<h3 id="程式碼謂詞推理引擎"><a href="#程式碼謂詞推理引擎">程式碼：謂詞推理引擎</a></h3>
<p>檔案：pkb.js (Predicate Knowledge Base 的簡寫)</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ml = <span class="fu">require</span>(<span class="st">&quot;./myLib&quot;</span>);

<span class="kw">var</span> Predicate = <span class="kw">function</span>() {}

<span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">load</span> = <span class="kw">function</span>(str) {
  <span class="kw">var</span> m = <span class="ot">str</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^(</span><span class="bn">[</span><span class="fl">^\(</span><span class="bn">]</span><span class="fl">*)\((</span><span class="bn">[</span><span class="fl">^\)</span><span class="bn">]</span><span class="fl">*)\)$</span><span class="ot">/</span>);
  <span class="kw">this</span>.<span class="fu">name</span>   = (m[<span class="dv">1</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">1</span>].<span class="fu">trim</span>();
  <span class="kw">this</span>.<span class="fu">params</span> = (m[<span class="dv">2</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">2</span>].<span class="fu">trim</span>().<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[,]</span><span class="ot">/</span>);
  <span class="kw">return</span> <span class="kw">this</span>;
}

<span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">ml</span>.<span class="fu">format</span>(<span class="st">&quot;%s%j&quot;</span>, <span class="kw">this</span>.<span class="fu">name</span>, <span class="kw">this</span>.<span class="fu">params</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="fl">\&quot;</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="fl">\[</span><span class="ot">/gi</span>, <span class="st">&quot;(&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="fl">\]</span><span class="ot">/gi</span>, <span class="st">&quot;)&quot;</span>);
}

<span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">unify</span> = <span class="kw">function</span>(fact) {
  <span class="kw">var</span> map = {};
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">name</span> != <span class="ot">fact</span>.<span class="fu">name</span> || <span class="kw">this</span>.<span class="ot">params</span>.<span class="fu">length</span> != <span class="ot">fact</span>.<span class="ot">params</span>.<span class="fu">length</span>) 
    <span class="kw">return</span> <span class="kw">null</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="ot">params</span>.<span class="fu">length</span>; i++) {
    <span class="kw">var</span> p  = <span class="kw">this</span>.<span class="fu">params</span>[i];
    <span class="kw">var</span> fp = <span class="ot">fact</span>.<span class="fu">params</span>[i];
    <span class="kw">if</span> (map[p] == <span class="kw">null</span>) { <span class="co">// 參數 p 沒有 bind，所以就 bind 上去</span>
      <span class="kw">if</span> (<span class="ot">p</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^</span><span class="bn">[a-z]</span><span class="fl">+</span><span class="ot"> !</span><span class="bn">[]</span><span class="fl">(</span><span class="ot">../timg/b66e6870f9c0.jpg</span><span class="fl">)</span><span class="ot"> /</span>)!=<span class="kw">null</span>)
        map[p] = fp;
    } <span class="kw">else</span> { <span class="co">// 參數 p 已 bind，檢查是否有衝突。</span>
      <span class="kw">if</span> (map[p] == fp)
        map[p] = fp; <span class="co">// 沒衝突，加入。</span>
      <span class="kw">else</span>
        <span class="kw">return</span> <span class="kw">null</span>; <span class="co">// 有衝突，傳回 null;</span>
    }
  }
  <span class="kw">return</span> map;
}

<span class="co">// 若每個變數都填入了，那麼就是滿足了 (satisfy)</span>
<span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">satisfy</span> = <span class="kw">function</span>(map) {
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">params</span>) {
    <span class="kw">var</span> p = <span class="kw">this</span>.<span class="fu">params</span>[i];
    <span class="kw">if</span> (map[p] == <span class="kw">null</span>)
      <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">mapping</span> = <span class="kw">function</span>(map) {
  <span class="kw">var</span> term = <span class="kw">new</span> <span class="fu">Predicate</span>();
  <span class="ot">term</span>.<span class="fu">name</span> = <span class="kw">this</span>.<span class="fu">name</span>;
  <span class="ot">term</span>.<span class="fu">params</span> = [];
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">params</span>) {
    <span class="kw">var</span> p = <span class="kw">this</span>.<span class="fu">params</span>[i];
    <span class="ot">term</span>.<span class="ot">params</span>.<span class="fu">push</span>(map[p]);
  }
  <span class="kw">return</span> term;
}

<span class="kw">var</span> Rule = <span class="kw">function</span>() {}

<span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">clone</span> = <span class="kw">function</span>() {
  <span class="kw">var</span> r=<span class="kw">new</span> <span class="fu">Rule</span>();
  <span class="ot">r</span>.<span class="fu">head</span> = <span class="kw">this</span>.<span class="fu">head</span>;
  <span class="ot">r</span>.<span class="fu">terms</span> = <span class="kw">this</span>.<span class="fu">terms</span>;
  <span class="ot">r</span>.<span class="fu">map</span> = <span class="kw">this</span>.<span class="fu">map</span>;
  <span class="kw">return</span> r;
}

<span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">load</span> = <span class="kw">function</span>(line) {
  <span class="kw">var</span> m = <span class="ot">line</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^(</span><span class="bn">[</span><span class="fl">^</span><span class="bn">&lt;=]</span><span class="fl">*)(</span><span class="ot">&lt;=</span><span class="fl">(</span><span class="bn">[</span><span class="fl">^\{</span><span class="bn"> ![]</span><span class="fl">(</span><span class="ot">../timg/0568953a55be.jpg</span><span class="fl">)</span><span class="ot"> /</span>);
  <span class="kw">var</span> head = (m[<span class="dv">1</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">1</span>].<span class="fu">trim</span>();
  <span class="kw">var</span> terms= (m[<span class="dv">3</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">3</span>].<span class="fu">trim</span>().<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[&amp;]</span><span class="fl">+</span><span class="ot">/</span>);
  <span class="kw">this</span>.<span class="fu">head</span> = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(head);
  <span class="kw">this</span>.<span class="fu">terms</span> = [];
  <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="ot">terms</span>.<span class="fu">length</span>; i++) {
    <span class="kw">this</span>.<span class="ot">terms</span>.<span class="fu">push</span>(<span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(terms[i]));
  }
  <span class="kw">this</span>.<span class="fu">map</span> = {};
  <span class="kw">return</span> <span class="kw">this</span>;
}

<span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">ml</span>.<span class="fu">format</span>(<span class="st">&quot;%s&lt;=%s%j&quot;</span>, <span class="kw">this</span>.<span class="fu">head</span>, <span class="kw">this</span>.<span class="ot">terms</span>.<span class="fu">join</span>(<span class="st">&quot;&amp;&quot;</span>), <span class="kw">this</span>.<span class="fu">map</span>);
}

<span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">resolve</span> = <span class="kw">function</span>(fact) {
  <span class="kw">var</span> rmap = <span class="kw">this</span>.<span class="fu">map</span>;
<span class="co">//  ml.log(&quot;resolve:rule=%s, fact=%s&quot;, this, fact);</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">terms</span>) {
    <span class="kw">var</span> term = <span class="kw">this</span>.<span class="fu">terms</span>[i];
    <span class="kw">var</span> tmap = <span class="ot">term</span>.<span class="fu">unify</span>(fact);
    <span class="kw">if</span> (tmap == <span class="kw">null</span>) <span class="kw">continue</span>;
<span class="co">//    ml.log(&quot;unify:%s;%s=%j&quot;, term, fact, tmap);</span>
    <span class="kw">var</span> isConflict = <span class="kw">false</span>;
    <span class="kw">for</span> (<span class="kw">var</span> mi <span class="kw">in</span> tmap) {
      <span class="kw">if</span> (rmap[mi]!=<span class="kw">null</span> &amp;&amp; rmap[mi] != tmap[mi])
        isConflict = <span class="kw">true</span>;
    }
    <span class="kw">if</span> (!isConflict) {
<span class="co">//      ml.log(&quot; return map=%j&quot;, tmap);</span>
      <span class="kw">return</span> tmap;
    }
  }
  <span class="kw">return</span> <span class="kw">null</span>;
}

<span class="kw">var</span> KB = <span class="kw">function</span>() {
  <span class="kw">this</span>.<span class="fu">rules</span> = [];
  <span class="kw">this</span>.<span class="fu">facts</span> = [];
  <span class="kw">this</span>.<span class="fu">ruleMap</span> = {};
  <span class="kw">this</span>.<span class="fu">factMap</span> = {};
  <span class="kw">this</span>.<span class="fu">resolveMap</span> = {};
}

<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">load</span> = <span class="kw">function</span>(code) {
  code = <span class="ot">code</span>.<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\s</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>);
  <span class="kw">var</span> lines = <span class="ot">code</span>.<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[</span><span class="fl">\.</span><span class="bn">]</span><span class="fl">+</span><span class="ot"> </span><span class="fl">?</span><span class="ot">/</span>);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;%j&quot;</span>, lines);
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> lines) {
    <span class="kw">var</span> line = lines[i].<span class="fu">trim</span>();
    <span class="kw">if</span> (<span class="ot">line</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">continue</span>;
    <span class="kw">if</span> (<span class="ot">line</span>.<span class="fu">indexOf</span>(<span class="st">&quot;&lt;=&quot;</span>)&gt;=<span class="dv">0</span>) {
      <span class="kw">this</span>.<span class="fu">addRule</span>(<span class="kw">new</span> <span class="fu">Rule</span>().<span class="fu">load</span>(line));
    } <span class="kw">else</span>
      <span class="kw">this</span>.<span class="fu">addFact</span>(<span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(line));
  }
  <span class="kw">this</span>.<span class="fu">dump</span>();
}

<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">dump</span> = <span class="kw">function</span>() {
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;=====facts========&quot;</span>);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="kw">this</span>.<span class="ot">facts</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>));
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;========rules=======&quot;</span>);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="kw">this</span>.<span class="ot">rules</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>));
<span class="co">// ml.log(&quot;========resolveMap=======\n&quot;);</span>
<span class="co">// ml.log(Object.keys(this.resolveMap).join(&quot;|&quot;));</span>
}
  
<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">addFact</span> = <span class="kw">function</span>(fact) {
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">factMap</span>[<span class="ot">fact</span>.<span class="fu">toString</span>()] == <span class="kw">null</span>) {
    <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;addFact:%s&quot;</span>, fact);
    <span class="kw">this</span>.<span class="ot">facts</span>.<span class="fu">push</span>(fact);
    <span class="kw">this</span>.<span class="fu">factMap</span>[<span class="ot">fact</span>.<span class="fu">toString</span>()] = fact;
    <span class="kw">return</span> <span class="kw">true</span>;
  } <span class="kw">else</span> 
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">addRule</span> = <span class="kw">function</span>(rule) {
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">ruleMap</span>[<span class="ot">rule</span>.<span class="fu">toString</span>()] == <span class="kw">null</span>) {
    <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;addRule:%s&quot;</span>, <span class="ot">rule</span>.<span class="fu">toString</span>());
    <span class="kw">this</span>.<span class="ot">rules</span>.<span class="fu">push</span>(rule);
    <span class="kw">this</span>.<span class="fu">ruleMap</span>[<span class="ot">rule</span>.<span class="fu">toString</span>()] = rule;
    <span class="kw">return</span> <span class="kw">true</span>;
  } <span class="kw">else</span>
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">genNew</span> = <span class="kw">function</span>(rule, fact) {
  <span class="kw">var</span> fmap = <span class="ot">rule</span>.<span class="fu">resolve</span>(fact);
  <span class="kw">if</span> (fmap == <span class="kw">null</span>) <span class="kw">return</span> <span class="kw">null</span>;
  <span class="kw">var</span> rmap = <span class="ot">ml</span>.<span class="fu">merge</span>(<span class="ot">rule</span>.<span class="fu">map</span>, fmap);
  <span class="kw">if</span> (<span class="ot">rule</span>.<span class="ot">head</span>.<span class="fu">satisfy</span>(rmap)) {
    <span class="kw">var</span> newFact = <span class="ot">rule</span>.<span class="ot">head</span>.<span class="fu">mapping</span>(rmap);
    <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">addFact</span>(newFact))
      <span class="kw">return</span> newFact;
  } <span class="kw">else</span> {
    <span class="kw">if</span> (!<span class="ot">ml</span>.<span class="fu">isEmpty</span>(fmap)) {
    <span class="kw">var</span> newRule = <span class="ot">rule</span>.<span class="fu">clone</span>();
    <span class="ot">newRule</span>.<span class="fu">map</span>  = rmap
    <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">addRule</span>(newRule))
      <span class="kw">return</span> newRule;
    }
  }
  <span class="kw">return</span> <span class="kw">null</span>;
}

<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">forwardChaining</span> = <span class="kw">function</span>() {
  <span class="kw">do</span> {
    <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;======forwardChaining============&quot;</span>);
    <span class="kw">var</span> anyNew = <span class="kw">false</span>;
    <span class="kw">for</span> (<span class="kw">var</span> fi=<span class="dv">0</span>; fi &lt; <span class="kw">this</span>.<span class="ot">facts</span>.<span class="fu">length</span>; fi++) {
      <span class="kw">var</span> fact=<span class="kw">this</span>.<span class="fu">facts</span>[fi];
      <span class="kw">for</span> (<span class="kw">var</span> ri <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">rules</span>) {
        <span class="kw">var</span> rule = <span class="kw">this</span>.<span class="fu">rules</span>[ri];
        <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">resolveMap</span>[fi+<span class="st">&quot;,&quot;</span>+ri] == <span class="kw">null</span>) {
          <span class="kw">var</span> newObj = <span class="kw">this</span>.<span class="fu">genNew</span>(rule, fact);
          <span class="kw">if</span> (newObj != <span class="kw">null</span>) {
            <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;  %s;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, rule, fact);
            anyNew = <span class="kw">true</span>;
          }
        }
        <span class="kw">else</span>
          <span class="kw">this</span>.<span class="fu">resolveMap</span>[fi+<span class="st">&quot;,&quot;</span>+ri]=<span class="kw">true</span>;
      }
    }
  } <span class="kw">while</span> (anyNew);
  <span class="kw">this</span>.<span class="fu">dump</span>();
}

<span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">test</span> = <span class="kw">function</span>() {
  <span class="kw">var</span> fxy = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;father(x,y)&quot;</span>);
  <span class="kw">var</span> fjj = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;father(John,Johnson)&quot;</span>);
  <span class="kw">var</span> rp = <span class="kw">new</span> <span class="fu">Rule</span>().<span class="fu">load</span>(<span class="st">&quot;parent(x,y)&lt;=father(x,y)&quot;</span>);
  <span class="kw">var</span> ra = <span class="kw">new</span> <span class="fu">Rule</span>().<span class="fu">load</span>(<span class="st">&quot;ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z)&quot;</span>);
  <span class="kw">var</span> pgj = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;ancestor(George,John)&quot;</span>);
  <span class="kw">var</span> pjj = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;parent(John,Johnson)&quot;</span>);
  <span class="ot">ra</span>.<span class="fu">map</span> = <span class="ot">ra</span>.<span class="fu">resolve</span>(pgj);
  <span class="ot">ra</span>.<span class="fu">map</span> = <span class="ot">ml</span>.<span class="fu">merge</span>(<span class="ot">ra</span>.<span class="fu">map</span>, <span class="ot">ra</span>.<span class="fu">resolve</span>(pjj));
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;ra=%s&quot;</span>, ra);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot; satisfy=%d&quot;</span>, <span class="ot">ra</span>.<span class="ot">head</span>.<span class="fu">satisfy</span>(<span class="ot">ra</span>.<span class="fu">map</span>));
}

<span class="ot">module</span>.<span class="fu">exports</span> = KB;</code></pre>
<h3 id="前向推論主程式pkbreason.js"><a href="#前向推論主程式pkbreason.js">前向推論主程式：pkbReason.js</a></h3>
<p>檔案：pkbReason.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用檔案物件</span>
<span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./pkb&#39;</span>);

<span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
<span class="kw">var</span> code = <span class="ot">fs</span>.<span class="fu">readFileSync</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>], <span class="st">&quot;utf8&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\n</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>); <span class="co">// 讀取檔案</span>
<span class="ot">kb1</span>.<span class="fu">load</span>(code);
<span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();</code></pre>
<h3 id="推論規則範例"><a href="#推論規則範例">推論規則範例</a></h3>
<p>規則檔：family.pkb</p>
<pre><code>parent(x,y)   &lt;= father(x,y).
parent(x,y)   &lt;= mother(x,y).
ancestor(x,y) &lt;= parent(x,y).
ancestor(x,z) &lt;= ancestor(x,y) &amp; parent(y,z).

father(John, Johnson).
mother(Mary, Johnson).
father(George, John).
father(John, Jake).</code></pre>
<h3 id="執行結果-6"><a href="#執行結果-6">執行結果</a></h3>
<pre><code>C:\Dropbox\Public\web\ai\code\PKB&gt;node pkbReason family.pkb
[&quot;parent(x,y)&lt;=father(x,y)&quot;,&quot;parent(x,y)&lt;=mother(x,y)&quot;,&quot;ancestor(x,y)&lt;=parent(x,
y)&quot;,&quot;ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z)&quot;,&quot;father(John,Johnson)&quot;,&quot;mother(Ma
ry,Johnson)&quot;,&quot;father(George,John)&quot;,&quot;father(John,Jake)&quot;,&quot;&quot;]
addRule:parent(x,y)&lt;=father(x,y){}
addRule:parent(x,y)&lt;=mother(x,y){}
addRule:ancestor(x,y)&lt;=parent(x,y){}
addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){}
addFact:father(John,Johnson)
addFact:mother(Mary,Johnson)
addFact:father(George,John)
addFact:father(John,Jake)
=====facts========
father(John,Johnson)
mother(Mary,Johnson)
father(George,John)
father(John,Jake)
========rules=======
parent(x,y)&lt;=father(x,y){}
parent(x,y)&lt;=mother(x,y){}
ancestor(x,y)&lt;=parent(x,y){}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){}
======forwardChaining============
addFact:parent(John,Johnson)
  parent(x,y)&lt;=father(x,y){};father(John,Johnson)

addFact:parent(Mary,Johnson)
  parent(x,y)&lt;=mother(x,y){};mother(Mary,Johnson)

addFact:parent(George,John)
  parent(x,y)&lt;=father(x,y){};father(George,John)

addFact:parent(John,Jake)
  parent(x,y)&lt;=father(x,y){};father(John,Jake)

addFact:ancestor(John,Johnson)
  ancestor(x,y)&lt;=parent(x,y){};parent(John,Johnson)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(John,Johnson)

addFact:ancestor(Mary,Johnson)
  ancestor(x,y)&lt;=parent(x,y){};parent(Mary,Johnson)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;Mary&quot;,&quot;z&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(Mary,Johnson)

addFact:ancestor(George,John)
  ancestor(x,y)&lt;=parent(x,y){};parent(George,John)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;George&quot;,&quot;z&quot;:&quot;John&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(George,John)

addFact:ancestor(John,Jake)
  ancestor(x,y)&lt;=parent(x,y){};parent(John,Jake)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(John,Jake)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(John,Johnson)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;Mary&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(Mary,Johnson)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;John&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(George,John)

addFact:ancestor(George,Johnson)
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Johnson&quot;};ancestor(Ge
orge,John)

addFact:ancestor(George,Jake)
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Jake&quot;};ancestor(Georg
e,John)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(John,Jake)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(George,Johnson)

addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(George,Jake)

======forwardChaining============
=====facts========
father(John,Johnson)
mother(Mary,Johnson)
father(George,John)
father(John,Jake)
parent(John,Johnson)
parent(Mary,Johnson)
parent(George,John)
parent(John,Jake)
ancestor(John,Johnson)
ancestor(Mary,Johnson)
ancestor(George,John)
ancestor(John,Jake)
ancestor(George,Johnson)
ancestor(George,Jake)
========rules=======
parent(x,y)&lt;=father(x,y){}
parent(x,y)&lt;=mother(x,y){}
ancestor(x,y)&lt;=parent(x,y){}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Johnson&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;Mary&quot;,&quot;z&quot;:&quot;Johnson&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;George&quot;,&quot;z&quot;:&quot;John&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Jake&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Johnson&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;Mary&quot;,&quot;y&quot;:&quot;Johnson&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;John&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Jake&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Johnson&quot;}
ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Jake&quot;}</code></pre>
<h3 id="結語-10"><a href="#結語-10">結語</a></h3>
<p>以上我們用 JavaScript 實作了一個簡易的謂詞邏輯推論引擎，採用洪氏邏輯的語法，以及前向推論 (forwardChaining) 的方式。</p>
<h1 id="結語-11"><a href="#結語-11">結語</a></h1>
<h2 id="ai-的夢想-1"><a href="#ai-的夢想-1">AI 的夢想</a></h2>
<p>AI 的問題吸引了無數研究者投入，也讓無數研究者感到失望、甚至害怕。因為，即使投入了整整一輩子，從少年研究到白髮，很可能都無法在研究上取得重要的進展。這可以說是人類科學技術的『終極問題』，如果資訊科學界有諾貝爾獎的話，那我想，大概要超過五千的以上的資訊諾貝爾獎，才能到達上述科幻小說的情節。甚至，其中有些技術，很可能永遠不會實現。在 AI 領域，我們必須學會的第一件事，就是謙卑。</p>
<p>這些夢想中的技術，有些值得我們投入一輩子去實現。但是，有些技術，實現後卻可能會造成大災難，這在科幻小說當中早已被想像過了。科幻界經典的艾西莫夫 (Isaac Asimov ) 機器人系列小說 ，就是典型的例子。當人類企圖用機器人三大定律控制機器人時，仍然發生的災難事件之科幻故事。另外，像是電影駭客任務 當中，更描述了機器人統治世界後，人類只能在機器人的餵養之下，成為類似植物人的悲慘狀況。因此，科技的進步，尤其是像 AI 技術與生物科技的進步，到底是福是禍，仍然是個謎。</p>
<p>這些議題有點扯遠了，我們根本還沒踏出第一步，就已經開始想像一萬步之後的結果了。然而，這些技術的困難度，沒有研究過的人還真是難以想像。讓我們用 AI 的學術龍頭 – MIT AI 實驗室的發展作為一個範例，說明 AI 領域有多麼困難。</p>
<p>在 AI 歷史早期的 1970年代，MIT AI 實驗室就已經是 AI 大師匯集之處，像是第一代的 Marvin Minsky 與 John McCarthy 等 AI 大師，他們研究的主題著重在人類大腦與智慧上。</p>
<p>接著，Patrick Winston發現，大腦的研究太過困難，轉而研究機械人控制的領域。但這領域仍然太難，於是 Harold Abelson 乾脆改研究玩具的控制，發明了 LOGO 語言，然後開始研究機械昆蟲，企圖研究昆蟲的行走智慧。 於是，人工智慧的研究從人腦開始，變成人的手腳之研究，最後變成昆蟲手腳的研究。2003 年七月，MIT AI 實驗室與 Laboratory for Computer Science 合併，成為一個具有 97 個教授、大約 800 個研究生的超級研究團隊 CSAIL ，不知道是否因為感到 AI 領域太難或需要整合其他領域所進行的調整。</p>
<p>當然，這並不表示 MIT AI 實驗室越做越差，相反的，他們越來越強，吸引了無數的 AI 領域研究者進入該實驗室。但是，這個領域實在太過困難，以至於學者在 1940 年代，認為 1990 年時應該可以理解自然語言，到了 1980 年代，預估時間點延後到 2030 年，到了 2009 年的今天，我個人認為可能還要 100 年的時間，才能發展出成熟的自然語言理解技術。</p>
<h2 id="ai-的困境"><a href="#ai-的困境">AI 的困境</a></h2>
<p>盡管人工智慧的學術界已經努力了五十年以上了，但是，距離 AI 的理想，模擬人類智慧行為的目標，仍然無比的遙遠。甚至，完全看不到實現的可能性。甚至，我們連問題到底困難在哪哩，都還不是很清楚。其中，往往最難的一點，也是最少被AI研究所提及的一點，就是評量函數設計上的困難。</p>
<h3 id="評量方法的困難"><a href="#評量方法的困難">評量方法的困難</a></h3>
<p>AI 的研究往往著重在方法的設計上，很少提及評量上的問題，然而，評量問題的困難其實反而是最難的。有經驗的 AI 研究者通常會發現，要研究一個問題之前，必須先想清楚，如何進行實驗的評量。如果沒有想清楚就貿然投入，那往往做到最後一無所獲。因為，會卡在實驗的評量上動彈不得，導致研究無法進行。</p>
<p>評量問題在資訊科學的其他領域通常較為客觀，像是演算法的複雜度與使用空間都可以很明確的評量。即使無法用這些指標的評量方式，實作或模擬的結果也可以用來評量方法的好壞。但是，對於人工智慧領域的問題而言，評量往往是最難的，因為，人工智慧的目的是在模擬人類的智慧與行為，而能夠用來評量結果好壞的，往往只有人才有辦法。但是，科學研究的目的，卻又正是在排除人類評價的主觀性。於是，一方面需要人類介入進行評量，另一方面又要排除主觀性，使得評量問題困難重重。</p>
<p>這種困難，使得許多人工智慧的研究，反而比較像社會科學，而不像自然科學。舉例而言，自然語言理解就是一個相當難以評量的領域。假如你今天寫了一個程式，企圖『理解』自然語言。那麼，如何評量這個程式是否真的『理解』了進行實驗的那些輸入文章呢？</p>
<p>或許你會認為，這個問題的原因是因為，自然語言理解是一個定義不明的問題。因為我們不知道甚麼叫作理解。那讓我們再舉一個例子，就拿英翻中的機器翻譯問題而言，將英文文章，翻譯成中文文章，這個問題應該夠清楚了吧？輸入是一個英文字串 (包含標點符號以及換行的文字串)，而輸出則是一個中文字串。同時懂英文與中文的人應該很清楚這個問題。</p>
<p>然而，假如你今天寫了一個翻譯程式，可以進行英翻中的工作，那麼，這個程式到底有多好呢？我們應該如何評量翻譯結果的好壞呢？</p>
<p>一個可能的解決辦法是，請一萬個同時通曉英文及中文的專家，同時對於隨機抽取出的一千篇網路文章，對其英文原文與翻譯後的中文進行全面的閱讀，然後每個人給出一個分數，分數高就代表程式好，分數低就代表程式不好。</p>
<p>如果我們暫時不爭論這樣的方法是否具有客觀性，但是這樣的方法，所耗費的成本將無比巨大，任何以一個企圖進行此實驗的人都必須超級有錢，而且冒著破產的危險，這種困難當然會妨礙研究的進展。</p>
<p>更糟糕的是，如果又有人寫了另一個英翻中程式，整個實驗又得重頭來過。而且，這一萬個中英文專家又要被召集過來，以無比的耐心再次讀完兩千篇文章 (一千篇英文原文，一千篇中文譯文)。然後，還要再次的以相當公正客觀的態度，給出絲毫不差的評價。姑且不管客觀評價是否能做得到，要能讓這些人投入這麼多的心力，也只有大量的鈔票才能辦到。</p>
<p>同樣的，針對交談系統，也就是 Alan Turing 所提出的 Turing Test，我們要如何評價一個程式的好壞呢？這仍然要靠大量的使用者介入，然後看看每個使用者是否能判斷出交談的對方到底是電腦還是程式，在以判斷正確或錯誤的比率，作為程式好壞的標準，這同樣有很大的困難。其中一個困難是，同樣的交談過程通常不會出現兩次，而且人類會透過經驗學習，因此，當這些人知道對方可能是程式，而且有了與電腦對談的經驗之後，就會發現一些電腦的盲點。舉例而言，問他是男是女，父母是誰，甚至透過介面傳一張字跡潦草的圖片給他，問他上面寫了甚麼。那麼，這個交談程式就必須具備影像識別的能力才行。</p>
<p>撇開自然語言領域的問題不談，其他領域呢？假如我們今天想設計一個語音辨識軟體，就必須有一個標準的語音庫，然後透過人的聽覺，先將聽到的聲音打成文字檔。然後，再利用程式進行語音辨識，看看與這些標準答案是否相同，才能決定程式的正確率。這個問題的評量相對簡單一點，但仍有客觀性的問題。</p>
<p>首先，語音庫到底應該用誰的聲音，如果單用一個人的聲音，那麼，是否會有所偏差。如果要用各種不同口音，各種不同年齡層，不同性別的人的聲音，那建構語音庫的工作仍然相當龐大。建立標準答案的工作也將相當吃力。</p>
<p>對於像語音辨識與影像識別這些領域而言，雖然評量的問題通常較沒有爭議，但是測試資料與標準答案的問題，仍然相當困擾人。在這些研究的背後，研究者通常迫於無奈，必須出錢購買這些語音庫、影像庫與標準答案。而這些語音庫與影像庫，通常被許多商業機關，視為重要財產，要取得時還要簽定智慧產權合約，以避免外流。</p>
<p>正因為如此，這些領域往往沒有共同的比較基準，這使得方法之間相當難以進行科學性的比較。當然，也就很難判斷方法間的好壞，這將嚴重阻礙 AI技術的進步。</p>
<p>還好，網際網路的出現，以及開放原始碼風潮的盛行，缺乏標準測試資料的問題，開始有了的可能性。但是，我們還沒看到大量的標準語音語料庫與影像庫出現，我們希望，透過類似開放原始碼與維基百科的模式，具有這些資源之版權的個人或研究機構，能將這些重要的資料在網路上釋出並且集中，成為人類公共資產的一部分，以幫助 AI 學術研究的進行，促進人類文明的進一步發展。</p>
<p>另外，還有一些 AI 領域，連評量的可能性都很渺茫，舉例而言，曾經有人做過利用 AI 技術自動畫圖，自動作曲的，那這些畫出來的圖，作出來的曲到底好不好，有多好呢？這已經不是工程浩大的問題了，而是藝術心理學上的問題。如果，有程式可以作出貝多芬、莫札特等級的曲子，那要給幾分呢？</p>
<p>關於藝術的例子或許太極端了，然而，許多設計上的問題都遭遇到同樣的困難，像是一個電腦遊戲到底設計得好不好，一個程式的品質到底如何等等？都已經不是可以客觀評量的問題。雖然，這些不見得都是 AI 問題，但是卻是資訊工程上重要的問題。然而，這些問題卻無法被歸類到學術問題當中。於是，學術界只好視若無睹，當作這些問題不存在。</p>
<h3 id="布林邏輯的困境"><a href="#布林邏輯的困境">布林邏輯的困境</a></h3>
<p>然而，現實世界的知識，往往不是絕對性的知識，我們很難說任何一件事情是 100% 正確的。然而，布林邏輯卻要求要知識要 100% 正確，才能保證後續的推論無誤。建構在穩固基礎上的知識，固然較為穩固，但是，我們的知識往往像沙堆一樣，沒有 100% 的保障，這使得布林邏輯的應用，經常侷限在所謂的玩具問題 (Toy Problem) 上，而難以進入現實生活當中。</p>
<p>布林邏輯的困難在影像識別上表現得特別明顯。舉例而言，電腦當中儲存了許多影像圖片，這些點都以二進位的 0 與 1 的形式儲存在圖片檔中。按理講，我們應該可以根據布林邏輯規則，推論出影像中的人物到底是『瑪莉蓮夢露』還是『李察吉爾』。然而，沒有人能夠寫出這樣的規則，二進位碼與圖像辨識之間，存在巨大的鴻溝，使得電腦見樹不見林，只看到一堆點，卻沒有看到整張圖。</p>
<h3 id="類神經網路的困境"><a href="#類神經網路的困境">類神經網路的困境</a></h3>
<p>類神經網路與布林邏輯恰好相反，當類神經網路看了一張圖，然後告訴所那張圖是瑪莉蓮夢露的照片時，程式設計人員會給予掌聲，但是卻不知道為何程式會告訴他這個答案。</p>
<p>為何如此呢？程式設計人員用了類似反傳遞演算法設計出程式後，就會針對所想要的答案，對此類神經程式進行訓練。舉例而言，如果我們想要讓電腦認識瑪莉蓮夢露，就可以用一大堆瑪莉蓮夢露的圖檔輸入，作為正確答案，然後輸入一大堆不是瑪莉蓮夢露的圖檔，作為負面教材。此時，程式對正面教材的預設答案是 1，而對負面教材的預設答案是 0。於是，類神經的訓練開始啟動，訓練完畢後，如果很幸運的，正確率達到百分之百。那麼，恭喜你，但是先別高興！因為，如果你想知道為何程式這麼好，那答案是，不知道！這個結果只是一堆權重加權後經過非線性函數的結果。程式自己本身沒有辦法告訴你為何會這麼好，程式設計人員也無法知道，除非他讀得懂這些權重的意義。(問題是，只要是人，通常就讀不懂權重的意義)。</p>
<h2 id="未來展望"><a href="#未來展望">未來展望</a></h2>
<p>截至目前為止，本書討論了「爬山演算法、神經網路、圖形搜尋、電腦下棋、邏輯推論與專家系統」等主題。</p>
<p>當然、我們還遺漏掉一些重要的主題，像是「模糊邏輯、機率統計、機器學習、資料挖礦、模式識別」等等，未來筆者將會對這些主題進行補充，</p>
</div>
<div id="footer">
<a href="http://ccckmit.wikidot.com">陳鍾誠</a>衍生自<a href="http://zh.wikipedia.org/">維基百科</a>之作品：採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 的 <a href="license.html">授權方式</a>。
</div>
</body>
</html>
